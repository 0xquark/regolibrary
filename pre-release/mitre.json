{
    "name": "MITRE",
    "description": "Testing MITRE for Kubernetes as suggested by microsoft in https://www.microsoft.com/security/blog/wp-content/uploads/2020/04/k8s-matrix.png",
    "attributes": {
        "armoBuiltin": true
    },
    "version": null,
    "controls": [
        {
            "name": "Access container service account",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Credential access"
                ],
                "rbacQuery": "Container service account mapping"
            },
            "description": "Attackers who obtain access to a pod can use its SA token to communicate with KubeAPI server. All PODs with SA token mounted (if such token has a Role or a ClusterRole binding) are considerred potentially dangerous.",
            "remediation": "Verify that RBAC is enabled. Follow the least privilege principle and ensure that only necessary PODs have SA token mounted into them.",
            "id": "C-0053",
            "long_description": "Service account (SA) represents an application identity in Kubernetes. By default, an SA is mounted to every created pod in the cluster. Using the SA, containers in the pod can send requests to the Kubernetes API server. Attackers who get access to a pod can access the SA token (located in /var/run/secrets/kubernetes.io/serviceaccount/token) and perform actions in the cluster, according to the SA permissions. If RBAC is not enabled, the SA has unlimited permissions in the cluster. If RBAC is enabled, its permissions are determined by the RoleBindings\\\\ClusterRoleBindings that are associated with it.",
            "test": "Check if RBAC is enabled. If is not, the sa has unlimited permissions.If RBAC enabled, list which workloads have bound service accounts and all the sas permissionsScore-",
            "controlID": "C-0053",
            "baseScore": 5.0,
            "rules": [
                {
                    "name": "access-container-service-account",
                    "attributes": {
                        "m$K8sThreatMatrix": "Credential Access::Access container service account, Lateral Movement::Container service account",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob",
                                "ServiceAccounts",
                                "RoleBinding",
                                "ClusterRoleBinding",
                                "Role",
                                "ClusterRole"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "determines which service accounts can be used to access other resources in the cluster",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\n\n\n# Returns for each Pod, what are the permission of its service account\n\ndeny[msga] {\n   serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n    \n    pods := [pod | pod=input[_]; pod.kind ==\"Pod\"]\n    pod := pods[_]\n    pod.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, pod)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has the following permissions in the cluster: %v\", [pod.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [\"\"],\n\t\t\"alertScore\": 7,\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, pod]\n\t\t}\n\t}\n}\n\n# Returns for each Pod, what are the permission of its service account\n deny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    pods := [pod | pod=input[_]; pod.kind ==\"Pod\"]\n    pod := pods[_]\n    pod.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, pod)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has the following permissions in the cluster: %v\", [pod.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n         \"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [rolebinding, role, pod]\n\t\t}\n\t}\n}\n\n# Returns for each Pod, what are the permission of its service account\n\n deny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    pods := [pod | pod=input[_]; pod.kind ==\"Pod\"]\n    pod := pods[_]\n    pod.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, pod)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has the following permissions in the cluster: %v\", [pod.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n         \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, pod]\n\t\t}\n\t}\n}\n\n\n\n\n### ---------------- #####\n\n \n\n# Returns for each Workloads, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\n    wl.spec.template.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has the following permissions in the cluster: %v\", [wl.kind, wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n# Returns for each Workloads, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\n    wl.spec.template.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n        msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has the following permissions in the cluster: %v\", [wl.kind, wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n\n# Returns for each Workloads, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\n    wl.spec.template.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\n        msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has the following permissions in the cluster: %v\", [wl.kind, wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n\n\n### ---------------- #####\n\n\n# Returns for each Cronjob, what are the permission of its service account\n\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\twl.spec.jobTemplate.spec.template.spec.serviceAccountName  == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.jobTemplate.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has the following permissions in the cluster: %v\", [wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n\n# Returns for each Cronjob, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\twl.spec.jobTemplate.spec.template.spec.serviceAccountName  == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.jobTemplate.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has the following permissions in the cluster: %v\", [wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n# Returns for each Cronjob, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\twl.spec.jobTemplate.spec.template.spec.serviceAccountName  == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.jobTemplate.spec.template)\n     \n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has the following permissions in the cluster: %v\", [wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n# ===============================================================\n\nisNotAutoMount(serviceaccount, pod) {\n    pod.spec.automountServiceAccountToken == false\n}\nisNotAutoMount(serviceaccount, pod) {\n    serviceaccount.automountServiceAccountToken == false\n    not pod.spec[\"automountServiceAccountToken\"]\n}\n\n"
                },
                {
                    "name": "access-container-service-account-v1",
                    "attributes": {
                        "m$K8sThreatMatrix": "Credential Access::Access container service account, Lateral Movement::Container service account",
                        "armoBuiltin": true,
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob",
                                "ServiceAccounts",
                                "RoleBinding",
                                "ClusterRoleBinding",
                                "Role",
                                "ClusterRole"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "determines which service accounts can be used to access other resources in the cluster",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\n\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    not saTokenNotAutoMount(serviceaccount)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [],\n        \"fixPaths\":[],\n\t\t\"alertScore\": 7,\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    not saTokenNotAutoMount(serviceaccount)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [],\n        \"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    not saTokenNotAutoMount(serviceaccount)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [],\n        \"fixPaths\":[],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# ===============================================================\n\nsaTokenNotAutoMount(serviceaccount) {\n    serviceaccount.automountServiceAccountToken == false\n}\n\n",
                    "resourceEnumerator": "package armo_builtins\n\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [\"\"],\n\t\t\"alertScore\": 7,\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Access Kubernetes dashboard",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Discovery",
                    "Lateral Movement"
                ],
                "rbacQuery": "Access k8s Dashboard"
            },
            "description": "Attackers who gain access to the dashboard service account or have its RBAC permissions can use its network access to retrieve information about resources in the cluster or change them. This control checks if a subject that is not dashboard service account is bound to dashboard role/clusterrole, or - if anyone that is not the dashboard pod is associated with dashboard service account.",
            "remediation": "Make sure that the \u201cKubernetes Dashboard\u201d service account is only bound to the Kubernetes dashboard following the least privilege principle.",
            "id": "C-0014",
            "long_description": "The Kubernetes dashboard is a web-based UI that is used for monitoring and managing the Kubernetes cluster. The dashboard allows users to perform actions in the cluster using its service account (Kubernetes-dashboard) with the permissions that are determined by the binding or cluster-binding for this service account. Attackers who gain access to a container in the cluster, can use its network access to the dashboard pod. Consequently, attackers may retrieve information about the various resources in the cluster using the dashboard\u2019s identity.",
            "test": "Check who is associated with the dashboard service account or bound to dashboard role/clusterrole.",
            "controlID": "C-0014",
            "baseScore": 2.0,
            "rules": [
                {
                    "name": "rule-access-dashboard",
                    "attributes": {
                        "m$K8sThreatMatrix": "Lateral Movement::Access Kubernetes dashboard, Discovery::Access Kubernetes dashboard",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "RoleBinding",
                                "ClusterRoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if subject that is not dashboard service account is bound to dashboard role/clusterrole, or- if anyone that is not dashboard pod is associated with its service account.",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\n\n# input: roleBinding\n# apiversion: v1\n# fails if a subject that is not dashboard service account is bound to dashboard role\n\ndeny[msga] {\n\troleBinding := input[_]\n    roleBinding.kind == \"RoleBinding\"\n    roleBinding.roleRef.name == \"kubernetes-dashboard\"\n    subject := roleBinding.subjects[_]\n    subject.name != \"kubernetes-dashboard\"\n    subject.kind != \"ServiceAccount\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following subjects: %s are bound to dashboard role/clusterrole\", [subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"packagename\": \"armo_builtins\",\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [roleBinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# input: clusterRoleBinding\n# apiversion: v1\n# fails if a subject that is not dashboard service account is bound to dashboard role\n\ndeny[msga] {\n\troleBinding := input[_]\n    roleBinding.kind == \"ClusterRoleBinding\"\n    roleBinding.roleRef.name == \"kubernetes-dashboard\"\n    subject := roleBinding.subjects[_]\n    subject.name != \"kubernetes-dashboard\"\n    subject.kind != \"ServiceAccount\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following subjects: %s are bound to dashboard role/clusterrole\", [subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [roleBinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if pod that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    pod := input[_]\n    pod.spec.serviceaccountname == \"kubernetes-dashboard\"\n    not startswith(pod.metadata.name, \"kubernetes-dashboard\")\n\tpath := \"spec.serviceaccountname\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following pods: %s are associated with dashboard service account\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if workload that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    wl.spec.template.spec.serviceaccountname == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\tpath := \"spec.template.spec.serviceaccountname\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is associated with dashboard service account\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if CronJob that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    wl.spec.jobTemplate.spec.template.spec.serviceaccountname == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\tpath := \"spec.jobTemplate.spec.template.spec.serviceaccountname\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjob: %s is associated with dashboard service account\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}"
                },
                {
                    "name": "rule-access-dashboard-subject-v1",
                    "attributes": {
                        "m$K8sThreatMatrix": "Lateral Movement::Access Kubernetes dashboard, Discovery::Access Kubernetes dashboard",
                        "armoBuiltin": true,
                        "resourcesAggregator": "subject-role-rolebinding",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if subject that is not dashboard service account is bound to dashboard role/clusterrole, or- if anyone that is not dashboard pod is associated with its service account.",
                    "remediation": "",
                    "rule": "package armo_builtins\n\n# input: regoResponseVectorObject\n# fails if a subject that is not dashboard service account is bound to dashboard role\n\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trole.metadata.name == \"kubernetes-dashboard\"\n\tsubjectVector.name != \"kubernetes-dashboard\"\n\n\tsubject := rolebinding.subjects[k]\n    path := [sprintf(\"relatedObjects[%v].subjects[%v]\", [format_int(j, 10), format_int(k, 10)])]\n\tfinalpath := array.concat(path, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v is bound to dashboard role/clusterrole\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": finalpath,\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n\t}\n}"
                },
                {
                    "name": "rule-access-dashboard-wl-v1",
                    "attributes": {
                        "m$K8sThreatMatrix": "Lateral Movement::Access Kubernetes dashboard, Discovery::Access Kubernetes dashboard",
                        "armoBuiltin": true,
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if subject that is not dashboard service account is bound to dashboard role/clusterrole, or- if anyone that is not dashboard pod is associated with its service account.",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n# input: \n# apiversion: \n# fails if pod that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    pod := input[_]\n    pod.spec.serviceAccountName == \"kubernetes-dashboard\"\n    not startswith(pod.metadata.name, \"kubernetes-dashboard\")\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following pods: %s are associated with dashboard service account\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [\"spec.serviceaccountname\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if workload that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    wl.spec.template.spec.serviceAccountName == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is associated with dashboard service account\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [\"spec.template.spec.serviceaccountname\"],\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if CronJob that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    wl.spec.jobTemplate.spec.template.spec.serviceAccountName == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjob: %s is associated with dashboard service account\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [\"spec.jobTemplate.spec.template.spec.serviceaccountname\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Access tiller endpoint",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Lateral movement"
                ]
            },
            "description": "Attackers may run code on any container that is accessible to the tiller\u2019s service and perform actions in the cluster, using the tiller\u2019s service account, which often has high privileges. This control checks if unauthenticated version of the Tiller runs in the cluster.",
            "remediation": "Use version higher than 2 of Helm which doesn\u2019t use Tiller",
            "id": "C-0033",
            "long_description": "Helm is a popular package manager for Kubernetes maintained by CNCF. Tiller is the server-side component of Helm up to version 2. Tiller exposes internal gRPC endpoint in the cluster, listens to port 44134. By default, this endpoint does not require authentication. Attackers may run code on any container that is accessible to the tiller\u2019s service and perform actions in the cluster, using the tiller\u2019s service account, which often has high privileges.",
            "test": "Check if tiller exists in any namespace by verifying the name of Deployments.",
            "controlID": "C-0033",
            "baseScore": 5.0,
            "rules": [
                {
                    "name": "access-tiller-endpoint",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Lateral movement::Access tiller endpoint",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if tiller exists in cluster",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n# input: deployment\n# fails if tiller exists in cluster\n\ndeny[msga] {\n\tdeployment := \tinput[_]\n\tdeployment.kind == \"Deployment\"\n    deployment.metadata.name == \"tiller-deploy\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"tiller exists in namespace: %v\", [deployment.metadata.namespace]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [\"metadata.name\"],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [deployment]\n\t\t}\n\t}\n}",
                    "resourceEnumerator": "package armo_builtins\n\n# input: deployment\n# fails if tiller exists in cluster\n\ndeny[msga] {\n\tdeployment := \tinput[_]\n\tdeployment.kind == \"Deployment\"\n    deployment.metadata.name == \"tiller-deploy\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"tiller exists in namespace: %v\", [deployment.metadata.namespace]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [\"metadata.name\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [deployment]\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Application exploit (RCE)",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Execution"
                ]
            },
            "description": "Applications that are vulnerable to a remote code execution enable attackers to run malicious code in the cluster. This control determines if pods have vulnerable images with remote code execution using ARMO vulnerability scan (must run vulnerability scan before running posture scan).",
            "remediation": "Patch your container with a version that does not have this vulnerability or use ARMO runtime protection (sign the workload).",
            "id": "C-0025",
            "long_description": "An application that is deployed in the cluster and is vulnerable to a remote code execution vulnerability, or a vulnerability that eventually allows code execution, enables attackers to run code in the cluster. If service account is mounted to the container (default behavior in Kubernetes), the attacker will be able to send requests to the API server using this service account credentials.",
            "test": "Searching the image from pod spec in the vulnerability scan database, if there is at least one high vulnerability we raise an alert.",
            "controlID": "C-0025",
            "baseScore": 10.0,
            "rules": [
                {
                    "name": "deny-RCE-vuln-image-pods",
                    "attributes": {
                        "m$K8sThreatMatrix": "Execution::Application Exploit (RCE)",
                        "armoBuiltin": true,
                        "armoOpa": "true"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod",
                                "services"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines if pods has vulnerable image with remote code execution",
                    "remediation": "",
                    "ruleQuery": "package armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n    \n# ========= RCE : no service score 5 ================\ndeny[msga] {\n\tpod := input[_]\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 5,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 5,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 5,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# ======== RCE + service (not nodeport and not loadbalancer) 7 =====================\ndeny[msga] {\n\tpod := input[_]\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == pod.metadata.namespace\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnot np_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector, filtered_labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 7,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnot np_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 7,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    \n    }\n}\n# cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnot np_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 7,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# ======= RCE + service nodeport/loadbalancer 10 ===========================\ndeny[msga] {\n\tpod := input[_]\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == pod.metadata.namespace\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector, filtered_labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 10,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 10,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 10,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n#treat as potentially critical\nis_unsafe_image(scanresult) {\n\tscanresult.numOfUnknownSeverity > 0\n}\nis_unsafe_image(scanresult) {\n\tscanresult.numOfNegligibleSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfLowSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfMeduiumSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfHighSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfCriticalSeverity > 0\n}"
                }
            ]
        },
        {
            "name": "Applications credentials in configuration files",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Credential access",
                    "Lateral Movement"
                ]
            },
            "description": "Attackers who have access to configuration files can steal the stored secrets and use them. This control checks if ConfigMaps or pod specifications have sensitive information in their configuration.",
            "remediation": "Use Kubernetes secrets or Key Management Systems to store credentials.",
            "id": "C-0012",
            "long_description": "Developers store secrets in the Kubernetes configuration files, such as environment variables in the pod configuration. Such behavior is commonly seen in clusters that are monitored by Azure Security Center. Attackers who have access to those configurations, by querying the API server or by accessing those files on the developer\u2019s endpoint, can steal the stored secrets and use them.",
            "test": "Check if the pod has sensitive information in environment variables, by using list of known sensitive key names. Check if there are configmaps with sensitive information.",
            "controlID": "C-0012",
            "baseScore": 8.0,
            "rules": [
                {
                    "name": "rule-credentials-in-env-var",
                    "attributes": {
                        "m$K8sThreatMatrix": "Credential access::Applications credentials in configuration files, Lateral Movement::Applications credentials in configuration files",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "configInputs": [
                        "settings.postureControlInputs.sensitiveKeyNames"
                    ],
                    "controlConfigInputs": [
                        {
                            "path": "settings.postureControlInputs.sensitiveKeyNames",
                            "name": "Keys",
                            "description": "Secrets are stored as a key/value pair. The names of the keys/values may change from one company to the other. Here you can find some examples of popular key phrases that Kubescape is searching for"
                        }
                    ],
                    "description": "fails if Pods have sensitive information in configuration",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "\tpackage armo_builtins\n\t# import data.cautils as cautils\n\t# import data.kubernetes.api.client as client\n\timport data\n\n\tdeny[msga] {\n\t\tpod := input[_]\n\t\tpod.kind == \"Pod\"\n\t\t# see default-config-inputs.json for list values\n\t\tsensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n\t\tkey_name := sensitive_key_names[_]\n\t\tcontainer := pod.spec.containers[i]\n\t\tenv := container.env[j]\n\t\tcontains(lower(env.name), key_name)\n\t\tisNotReference(env)\n\t\tpath := sprintf(\"spec.containers[%v].env[%v].name\", [format_int(i, 10), format_int(j, 10)])\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"Pod: %v has sensitive information in environment variables\", [pod.metadata.name]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [pod]\n\t\t\t}\n\t\t}\n\t}\n\n\tdeny[msga] {\n\t\twl := input[_]\n\t\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\t\tspec_template_spec_patterns[wl.kind]\n\n\t\t# see default-config-inputs.json for list values\n\t\tsensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n\t\tkey_name := sensitive_key_names[_]\n\t\tcontainer := wl.spec.template.spec.containers[i]\n\t\tenv := container.env[j]\n\t\tcontains(lower(env.name), key_name)\n\t\tisNotReference(env)\n\t\tpath := sprintf(\"spec.template.spec.containers[%v].env[%v].name\", [format_int(i, 10), format_int(j, 10)])\t\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"%v: %v has sensitive information in environment variables\", [wl.kind, wl.metadata.name]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [wl]\n\t\t\t}\n\t\t}\n\t}\n\n\tdeny[msga] {\n\t\twl := input[_]\n\t\twl.kind == \"CronJob\"\n\t\t# see default-config-inputs.json for list values\n\t\tsensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n\t\tkey_name := sensitive_key_names[_]\n\t\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\t\tenv := container.env[j]\n\t\tcontains(lower(env.name), key_name)\n\t\tisNotReference(env)\n\t\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].env[%v].name\", [format_int(i, 10), format_int(j, 10)])\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"Cronjob: %v has sensitive information in environment variables\", [wl.metadata.name]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [wl]\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tisNotReference(env)\n\t{\n\t\tnot env.valueFrom.secretKeyRef\n\t\tnot env.valueFrom.configMapKeyRef\n\t}\n\n"
                },
                {
                    "name": "rule-credentials-configmap",
                    "attributes": {
                        "m$K8sThreatMatrix": "Credential access::Applications credentials in configuration files, Lateral Movement::Applications credentials in configuration files",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "ConfigMap"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "configInputs": [
                        "settings.postureControlInputs.sensitiveValues",
                        "settings.postureControlInputs.sensitiveKeyNames"
                    ],
                    "controlConfigInputs": [
                        {
                            "path": "settings.postureControlInputs.sensitiveValues",
                            "name": "Values",
                            "description": "Secrets are stored as a key/value pair. The names of the keys/values may change from one company to the other. Below you can find some examples of popular value phrases that Kubescape is searching for"
                        },
                        {
                            "path": "settings.postureControlInputs.sensitiveKeyNames",
                            "name": "Keys",
                            "description": "Secrets are stored as a key/value pair. The names of the keys/values may change from one company to the other. Here you can find some examples of popular key phrases that Kubescape is searching for"
                        }
                    ],
                    "description": "fails if ConfigMaps have sensitive information in configuration",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n# import data.cautils as cautils\n# import data.kubernetes.api.client as client\nimport data\n\n# fails if config map has keys with suspicious name\ndeny[msga] {\n\tconfigmap := input[_]\n    configmap.kind == \"ConfigMap\"\n    # see default-config-inputs.json for list values\n    sensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n    key_name := sensitive_key_names[_]\n    map_secret := configmap.data[map_key]\n    contains(lower(map_key), lower(key_name))\n    path := sprintf(\"data[%v]\", [map_key])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"this configmap has sensitive information: %v\", [configmap.metadata.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n        \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [configmap]\n\t\t}\n     }\n}\n\n# fails if config map has values with suspicious content - not base 64\ndeny[msga] {\n    # see default-config-inputs.json for list values\n    sensitive_values := data.postureControlInputs.sensitiveValues\n    value := sensitive_values[_]\n\n\tconfigmap := input[_]\n    configmap.kind == \"ConfigMap\"\n    map_secret := configmap.data[map_key]\n    regex.match(value , map_secret)\n    path := sprintf(\"data[%v]\", [map_key])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"this configmap has sensitive information: %v\", [configmap.metadata.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n        \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [configmap]\n\t\t}\n     }\n}\n\n# fails if config map has values with suspicious content - base 64\ndeny[msga] {\n    # see default-config-inputs.json for list values\n    sensitive_values := data.postureControlInputs.sensitiveValues\n    value := sensitive_values[_]\n\n\tconfigmap := input[_]\n    configmap.kind == \"ConfigMap\"\n    map_secret := configmap.data[map_key]\n    decoded_secret := base64.decode(map_secret)\n    regex.match(value , decoded_secret)\n    path := sprintf(\"data[%v]\", [map_key])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"this configmap has sensitive information: %v\", [configmap.metadata.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n        \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [configmap]\n\t\t}\n     }\n}"
                }
            ]
        },
        {
            "name": "Bash/cmd inside container",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Execution"
                ]
            },
            "description": "Attackers who can run new processes inside a container might use cmd/bash script inside a container to execute malicious code. This control determines which containers have bash/cmd inside it.",
            "remediation": "Consider removing cmd/bash from your containers.",
            "id": "C-0019",
            "long_description": "Attackers who have permissions to run a cmd/bash script inside a container can use it to execute malicious code. ",
            "test": "Searching the image from pod spec in the vulnerability scan database, if the container has bash/cmd we raise an alert.Needs to add user config",
            "controlID": "C-0019",
            "baseScore": 4.0,
            "example": "@controls/examples/c019.yaml",
            "rules": [
                {
                    "name": "rule-can-bash-cmd-inside-container",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Execution::Bash/cmd inside container",
                        "armoBuiltin": true,
                        "armoOpa": "true"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "controlConfigInputs": [
                        {
                            "path": "settings.postureControlInputs.listOfDangerousArtifcats",
                            "name": "Shell executable in container",
                            "description": "Kubescape checks if container images have the any of the these shell executables."
                        }
                    ],
                    "description": "determines which containers have bash/cmd inside it",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\nimport data\n\n\n# Fails if container has bash/cmd inside it \n# Pods\ndeny [msga] {\n    pod := input[_]\n    container := pod.spec.containers[i]\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    isBashContainer(scan)\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n    \n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following container: %v has bash/cmd inside it.\", [container.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"container\" : [{container.name}]\n\t\t\t}\n\t\t},\n\t}\n}\n\n\n# Workloads\ndeny [msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    isBashContainer(scan)\n\n    \n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following container: %v has bash/cmd inside it.\", [container.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"container\" : [{container.name}]\n\t\t\t}\n\t\t},\n\t}\n}\n\n# Cronjobs\ndeny [msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    isBashContainer(scan)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following container: %v has bash/cmd inside it.\", [container.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"container\" : [{container.name}]\n\t\t\t}\n\t\t},\n\t}\n}\n\n\nisBashContainer(scan) {\n\t# see default-config-inputs.json for list values\n\tshells :=  data.postureControlInputs.listOfDangerousArtifcats\n\tshell := shells[_]\n\tcautils.list_contains(scan.listOfDangerousArtifcats, shell)\n}\n"
                }
            ]
        },
        {
            "name": "Cluster-admin binding",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Privilege escalation"
                ],
                "rbacQuery": "Show cluster_admin"
            },
            "description": "Attackers who have cluster admin permissions (can perform any action on any resource), can take advantage of their privileges for malicious activities. This control determines which subjects have cluster admin permissions.",
            "remediation": "You should apply least privilege principle. Make sure cluster admin permissions are granted only when it is absolutely necessary. Don't use subjects with such high permissions for daily operations.",
            "id": "C-0035",
            "long_description": "Role-based access control (RBAC) is a key security feature in Kubernetes. RBAC can restrict the allowed actions of the various identities in the cluster. Cluster-admin is a built-in high privileged role in Kubernetes. Attackers who have permissions to create bindings and cluster-bindings in the cluster can create a binding to the cluster-admin ClusterRole or to other high privileges roles.",
            "test": "Check which subjects have cluster-admin RBAC permissions \u2013 either by being bound to the cluster-admin clusterrole, or by having equivalent high privileges.  ",
            "controlID": "C-0035",
            "baseScore": 8.0,
            "rules": [
                {
                    "name": "rule-list-all-cluster-admins",
                    "attributes": {
                        "m$K8sThreatMatrix": "Privilege Escalation::Cluster-admin binding",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users have cluster admin permissions",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# input: roles\n# apiversion: v1\n# does: returns roles+ related subjects in rolebinding\n\ndeny[msga] {\n\troles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[i]\n\tcanCreate(rule, i)\n\tcanCreateResources(rule, i)\n\n\trolebinding.roleRef.kind == \"Role\"\n\trolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v have high privileges, such as cluster-admin\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# input: ClusterRole\n# apiversion: v1\n# does: returns clusterroles+ related subjects in rolebinding\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[i]\n\tcanCreate(rule, i)\n\tcanCreateResources(rule, i)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n    \n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v have high privileges, such as cluster-admin\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# input: ClusterRole\n# apiversion: v1\n# does:\treturns clusterroles+ related subjects in clusterrolebinding\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[i]\n\tcanCreate(rule, i)\n    canCreateResources(rule, i)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v have high privileges, such as cluster-admin\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ncanCreate(rule, i) {\n\tverb := rule.verbs[j]\n\tverb == \"*\"\n}\n\ncanCreateResources(rule, i){\n\tisApiGroup(rule)\n\tresource := rule.resources[j]\n\tresource == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n"
                },
                {
                    "name": "rule-list-all-cluster-admins-v1",
                    "attributes": {
                        "m$K8sThreatMatrix": "Privilege Escalation::Cluster-admin binding",
                        "armoBuiltin": true,
                        "resourcesAggregator": "subject-role-rolebinding",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users have cluster admin permissions",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# returns subjects with cluster admin permissions\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"*\", \"\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v have high privileges, such as cluster-admin\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": finalpath,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}\n"
                }
            ]
        },
        {
            "name": "Cluster internal networking",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Lateral movement"
                ]
            },
            "description": "If no network policy is defined, attackers who gain access to a container may use it to move laterally in the cluster. This control lists namespaces in which no network policy is defined.",
            "remediation": "Define Kubernetes network policies or use alternative products to protect cluster network.",
            "id": "C-0054",
            "long_description": "Kubernetes networking behavior allows traffic between pods in the cluster as a default behavior. Attackers who gain access to a single container may use it for network reachability to another container in the cluster.",
            "test": "Check for each namespace if there is a network policy defined.",
            "controlID": "C-0054",
            "baseScore": 4.0,
            "rules": [
                {
                    "name": "internal-networking",
                    "attributes": {
                        "m$K8sThreatMatrix": "Lateral Movement::Container internal networking, Discovery::Network mapping",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "networkpolicies",
                                "namespaces"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "lists namespaces in which no network policies are defined",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n# input: network policies\n# apiversion: networking.k8s.io/v1\n# fails if no network policies are defined in a certain namespace\n\ndeny[msga] {\n\tnamespaces := [namespace | namespace = input[_]; namespace.kind == \"Namespace\"]\n\tnamespace := namespaces[_]\n\tpolicy_names := [policy.metadata.namespace | policy = input[_]; policy.kind == \"NetworkPolicy\"]\n\tnot list_contains(policy_names, namespace.metadata.name)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"no policy is defined for namespace %v\", [namespace.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [namespace]\n\t\t}\n\t}\n}\n\nlist_contains(list, element) {\n  some i\n  list[i] == element\n}",
                    "resourceEnumerator": "package armo_builtins\n\n# input: network policies + namespaces\n# apiversion: networking.k8s.io/v1\n# returns all namespaces\n\ndeny[msga] {\n\tnamespaces := [namespace | namespace = input[_]; namespace.kind == \"Namespace\"]\n\tnamespace := namespaces[_]\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"no policy is defined for namespace %v\", [namespace.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [namespace]\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Exec into container",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Execution"
                ],
                "rbacQuery": "Show who can access into pods"
            },
            "description": "Attackers with relevant permissions can run malicious commands in the context of legitimate containers in the cluster using \u201ckubectl exec\u201d command. This control determines which subjects have permissions to use this command.",
            "remediation": "It is recommended to prohibit \u201ckubectl exec\u201d command in production environments. It is also recommended not to use subjects with this permission for daily cluster operations.",
            "id": "C-0002",
            "long_description": "Attackers who have permissions, can run malicious commands in containers in the cluster using exec command (\u201ckubectl exec\u201d). In this method, attackers can use legitimate images, such as an OS image (e.g., Ubuntu) as a backdoor container, and run their malicious code remotely by using \u201ckubectl exec\u201d.",
            "test": "Check which subjects have RBAC permissions to exec into pods\u2013 if they have the \u201cpods/exec\u201d verb.",
            "controlID": "C-0002",
            "baseScore": 5.0,
            "example": "@controls/examples/c002.yaml",
            "rules": [
                {
                    "name": "exec-into-container",
                    "attributes": {
                        "m$K8sThreatMatrix": "Privilege Escalation::Exec into container",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users have permissions to exec into pods",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n# input: clusterrolebindings + rolebindings\n# apiversion: rbac.authorization.k8s.io/v1 \n# returns subjects that can exec into container\n\ndeny[msga] {\n\t roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanExecToPodResource(rule)\n\tcanExecToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"Role\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n   \tsubject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can exec into  containers\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n# input: clusterrolebindings + rolebindings\n# apiversion: rbac.authorization.k8s.io/v1 \n# returns subjects that can exec into container\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanExecToPodResource(rule)\n\tcanExecToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can exec into  containers\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n# input: clusterrolebindings + rolebindings\n# apiversion: rbac.authorization.k8s.io/v1 \n# returns subjects that can exec into container\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanExecToPodResource(rule)\n\tcanExecToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can exec into  containers\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n  \t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\ncanExecToPodVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"create\")\n}\ncanExecToPodVerb(rule)  {\n\tcautils.list_contains(rule.verbs, \"*\")\n}\n\ncanExecToPodResource(rule)  {\n\tcautils.list_contains(rule.resources, \"pods/exec\")\n\t\n}\ncanExecToPodResource(rule)  {\n\tcautils.list_contains(rule.resources, \"pods/*\")\n}\ncanExecToPodResource(rule) {\n\tisApiGroup(rule)\n\tcautils.list_contains(rule.resources, \"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}"
                },
                {
                    "name": "exec-into-container-v1",
                    "attributes": {
                        "m$K8sThreatMatrix": "Privilege Escalation::Exec into container",
                        "armoBuiltin": true,
                        "resourcesAggregator": "subject-role-rolebinding",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users have permissions to exec into pods",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# input: regoResponseVectorObject\n# returns subjects that can exec into container\n\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"create\", \"*\"]\n    verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"pods/exec\", \"pods/*\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\t\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can exec into containers\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": finalpath,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Exposed dashboard",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Initial Access"
                ]
            },
            "description": "Kubernetes dashboard versions before v2.0.1 do not support user authentication. If exposed externally, it will allow unauthenticated remote management of the cluster. This control checks presence of the kubernetes-dashboard deployment and its version number.",
            "remediation": "Update dashboard version to v2.0.1 and above.",
            "id": "C-0047",
            "long_description": "The Kubernetes dashboard is a web-based user interface that enables monitoring and managment of the Kubernetes cluster. By default, the dashboard exposes an internal endpoint (ClusterIP service). If the dashboard is exposed externally, it can allow unauthenticated remote management of the cluster.",
            "test": "Checking if Kubernetes dashboard exists deployment and exposed externally as a service (nodeport/loadbalancer), check if the version of the container image is older than v2.0.1 we raise an alert.",
            "controlID": "C-0047",
            "baseScore": 6.0,
            "rules": [
                {
                    "name": "rule-exposed-dashboard",
                    "attributes": {
                        "m$K8sThreatMatrix": "Initial Access::Exposed Dashboard",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "Service"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if dashboard exists and is exposed",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "\tpackage armo_builtins\n\n\t# input: pods\n\t# apiversion: v1\n\t# fails if dashboard exists and is exposed\n\n\tdeny[msga] {\n\t\tdeployment := input[_]\n\t\tstartswith(deployment.metadata.name, \"kubernetes-dashboard\")\n\t\tcontainer := deployment.spec.template.spec.containers[j]\n\t\tversion := trim_prefix(container.image, \"kubernetesui/dashboard:v\")\n\t\tto_number(replace(version, \".\", \"\")) < 201\n\t\t\n\t\tservice := input[_]\n\t\tservice.kind == \"Service\"\n\t\tisNodePortLbService(service)\n\t\tcount({x | service.spec.selector[x]; deployment.metadata.labels[x]}) == count(service.spec.selector)\n\t\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(j, 10)])\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"dashboard exists and is exposed %s\", [container.image]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [deployment]\n\t\t\t}\n\t\t}\n\t}\n\n\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"NodePort\"\n}\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"LoadBalancer\"\n}"
                },
                {
                    "name": "rule-exposed-dashboard-v1",
                    "attributes": {
                        "m$K8sThreatMatrix": "Initial Access::Exposed Dashboard",
                        "armoBuiltin": true,
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "Service"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if dashboard exists and is exposed",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n# input: deployment, service\n# apiversion: v1\n# fails if dashboard exists and is exposed\n\ndeny[msga] {\n\tdeployment := input[_]\n\tstartswith(deployment.metadata.name, \"kubernetes-dashboard\")\n\tcontainer := deployment.spec.template.spec.containers[j]\n\tversion := trim_prefix(container.image, \"kubernetesui/dashboard:v\")\n\tto_number(replace(version, \".\", \"\")) < 201\n\t\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tisNodePortLbService(service)\n\tcount({x | service.spec.selector[x]; deployment.metadata.labels[x]}) == count(service.spec.selector)\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(j, 10)])\n\n\tdeploymentvector = {\"name\": deployment.metadata.name,\n\t\t\t\t\t\t\"namespace\": deployment.metadata.namespace,\n\t\t\t\t\t\t\"kind\": deployment.kind,\n\t\t\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"dashboard exists and is exposed %s\", [container.image]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": deploymentvector\n\t\t}\n\t}\n}\n\n\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"NodePort\"\n}\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"LoadBalancer\"\n}",
                    "resourceEnumerator": "package armo_builtins\n\n# input: deployment, service\n# apiversion: v1\n# fails if dashboard exists and is exposed\n\ndeny[msga] {\n\tdeployment := input[_]\n\tstartswith(deployment.metadata.name, \"kubernetes-dashboard\")\n\tcontainer := deployment.spec.template.spec.containers[j]\n\tversion := trim_prefix(container.image, \"kubernetesui/dashboard:v\")\n\tto_number(replace(version, \".\", \"\")) < 201\n\t\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tcount({x | service.spec.selector[x]; deployment.metadata.labels[x]}) == count(service.spec.selector)\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(j, 10)])\n\n\tdeploymentvector = {\"name\": deployment.metadata.name,\n\t\t\t\t\t\t\"namespace\": deployment.metadata.namespace,\n\t\t\t\t\t\t\"kind\": deployment.kind,\n\t\t\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"dashboard exists and is exposed %s\", [container.image]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": deploymentvector\n\t\t}\n\t}\n}\n\n\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"NodePort\"\n}\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"LoadBalancer\"\n}"
                }
            ]
        },
        {
            "name": "Exposed sensitive interfaces",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Initial access"
                ]
            },
            "description": "Exposing a sensitive interface to the internet poses a security risk. It might enable attackers to run malicious code or deploy containers in the cluster. This control checks if known components (e.g. Kubeflow, Argo Workflows, etc.) are deployed and exposed services externally.",
            "remediation": "Consider blocking external interfaces or protect them with appropriate security tools.",
            "id": "C-0021",
            "long_description": "Exposing a sensitive interface to the internet poses a security risk. Some popular frameworks were not intended to be exposed to the internet, and therefore don\u2019t require authentication by default. Thus, exposing them to the internet allows unauthenticated access to a sensitive interface which might enable running code or deploying containers in the cluster by a malicious actor. Examples of such interfaces that were seen exploited include Apache NiFi, Kubeflow, Argo Workflows, Weave Scope, and the Kubernetes dashboard.",
            "test": "Checking if a service of type nodeport/loadbalancer to one of the known exploited interfaces (Apache NiFi, Kubeflow, Argo Workflows, Weave Scope Kubernetes dashboard) exists. Needs to add user config",
            "controlID": "C-0021",
            "baseScore": 6.0,
            "rules": [
                {
                    "name": "exposed-sensitive-interfaces",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Initial access::Exposed sensitive interfaces",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Service",
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "kubernetes.api.client"
                        }
                    ],
                    "configInputs": [
                        "settings.postureControlInputs.servicesNames"
                    ],
                    "controlConfigInputs": [
                        {
                            "path": "settings.postureControlInputs.servicesNames",
                            "name": "Service names",
                            "description": "Kubescape will look for the following services that exposes sensitive interfaces of common K8s projects/applications"
                        }
                    ],
                    "description": "fails if known interfaces have exposed services",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\nimport data\n\n# loadbalancer\ndeny[msga] {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"LoadBalancer\"\n\n\twl := input[_]\n\tworkload_types = {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"Pod\", \"CronJob\"}\n\tworkload_types[wl.kind]\n\tresult := wl_connectedto_service(wl, service)\n    \n    # see default-config-inputs.json for list values\n    services_names := data.postureControlInputs.servicesNames\n\tservices_names[service.metadata.name]\n    # externalIP := service.spec.externalIPs[_]\n\texternalIP := service.status.loadBalancer.ingress[0].ip\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl, service]\n\t\t}\n\t}\n}\n\n\n# nodePort\n# get a pod connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n    \n    # see default-config-inputs.json for list values\n    services_names := data.postureControlInputs.servicesNames\n\tservices_names[service.metadata.name]\n    \n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\n\tresult := wl_connectedto_service(pod, service)\n\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod, service]\n\t\t}\n\t}\n} \n\n# nodePort\n# get a workload connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n    \n    # see default-config-inputs.json for list values\n    services_names := data.postureControlInputs.servicesNames\n\tservices_names[service.metadata.name]\n    \n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"CronJob\"}\n\tspec_template_spec_patterns[wl.kind]\n\n\tresult := wl_connectedto_service(wl, service)\n\n\tpods_resource := client.query_all(\"pods\")\n\tpod := pods_resource.body.items[_]\n\tmy_pods := [pod | startswith(pod.metadata.name, wl.metadata.name)]\n\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl, service]\n\t\t}\n\t}\n}\n\n# ====================================================================================\n\nwl_connectedto_service(wl, service) = paths{\n\tcount({x | service.spec.selector[x] == wl.metadata.labels[x]}) == count(service.spec.selector)\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}\n\nwl_connectedto_service(wl, service) = paths {\n\twl.spec.selector.matchLabels == service.spec.selector\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}\n"
                },
                {
                    "name": "exposed-sensitive-interfaces-v1",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Initial access::Exposed sensitive interfaces",
                        "armoBuiltin": true,
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Service",
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "kubernetes.api.client"
                        }
                    ],
                    "configInputs": [
                        "settings.postureControlInputs.sensitiveInterfaces"
                    ],
                    "controlConfigInputs": [
                        {
                            "path": "settings.postureControlInputs.sensitiveInterfaces",
                            "name": "Sensitive interfaces",
                            "description": "The following interfaces were seen exploited. Kubescape checks it they are externally exposed."
                        }
                    ],
                    "description": "fails if known interfaces have exposed services",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\nimport data\n\n# loadbalancer\ndeny[msga] {\n\twl := input[_]\n\tworkload_types = {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"Pod\", \"CronJob\"}\n\tworkload_types[wl.kind]\n\n    # see default-config-inputs.json for list values\n    wl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"LoadBalancer\"\n\n\tresult := wl_connectedto_service(wl, service)\n    \n    # externalIP := service.spec.externalIPs[_]\n\texternalIP := service.status.loadBalancer.ingress[0].ip\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": wlvector\n\t\t}\n\t}\n}\n\n\n# nodePort\n# get a pod connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"Pod\"\n    \n    # see default-config-inputs.json for list values\n    wl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n    \n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n\n\tresult := wl_connectedto_service(wl, service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": wlvector\n\t\t}\n\t}\n} \n\n# nodePort\n# get a workload connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"CronJob\"}\n\tspec_template_spec_patterns[wl.kind]\n    \n    # see default-config-inputs.json for list values\n    wl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n    \n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n\n\tresult := wl_connectedto_service(wl, service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": wlvector\n\t\t}\n\t}\n}\n\n# ====================================================================================\n\nwl_connectedto_service(wl, service) = paths{\n\tcount({x | service.spec.selector[x] == wl.metadata.labels[x]}) == count(service.spec.selector)\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}\n\nwl_connectedto_service(wl, service) = paths {\n\twl.spec.selector.matchLabels == service.spec.selector\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}",
                    "resourceEnumerator": "package armo_builtins\nimport data.kubernetes.api.client as client\nimport data\n\ndeny[msga] {\n\twl := input[_]\n\tworkload_types = {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"Pod\", \"CronJob\"}\n\tworkload_types[wl.kind]\n\n\t# see default-config-inputs.json for list values\n\twl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n\n\tsrvc := get_wl_connectedto_service(wl)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": srvc}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"wl: %v is in the cluster\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n\t}\n}\n\nget_wl_connectedto_service(wl) = s {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\twl_connectedto_service(wl, service)\n\ts = [service]\n}\n\nget_wl_connectedto_service(wl) = s {\n\tservices := [service | service = input[_]; service.kind == \"Service\"]\n\tcount({i | services[i]; wl_connectedto_service(wl, services[i])}) == 0\n\ts = []\n}\n\nwl_connectedto_service(wl, service){\n\tcount({x | service.spec.selector[x] == wl.metadata.labels[x]}) == count(service.spec.selector)\n}"
                }
            ]
        },
        {
            "name": "HostPath mount",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Privilege escalation"
                ]
            },
            "description": "Mounting host directory to the container can be used by attackers to get access to the underlying host. This control identifies all the PODs using hostPath mount.",
            "example": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pd\nspec:\n  containers:\n  - image: k8s.gcr.io/test-webserver\n    name: test-container\n    volumeMounts:\n    - mountPath: /test-pd\n      name: test-volume\n  volumes:\n  - name: test-volume\n    hostPath: # This field triggers failure!\n      path: /data\n      type: Directory\n",
            "remediation": "Remove hostPath mounts unless they are absolutely necessary and use exception mechanism to remove notifications.",
            "id": "C-0048",
            "controlID": "C-0048",
            "baseScore": 6.0,
            "rules": [
                {
                    "name": "alert-any-hostpath",
                    "attributes": {
                        "m$K8sThreatMatrix": "Privilege Escalation::hostPath mount",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "determines if any workload contains a hostPath volume",
                    "remediation": "Try to refrain from using hostPath mounts",
                    "ruleQuery": "",
                    "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    volumes := pod.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.\"\n\tresult  := isDangerousHostPath(volume, begginingOfPath, i)\n    podname := pod.metadata.name\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod: %v has: %v as hostPath volume\", [podname, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    volumes := wl.spec.template.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result  := isDangerousHostPath(volume, begginingOfPath, i)\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n#handles CronJobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    volumes := wl.spec.jobTemplate.spec.template.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n    result  := isDangerousHostPath(volume, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\nisDangerousHostPath(volume, begginingOfPath, i) = path {\n    startswith(volume.hostPath.path, \"/etc\")\n\tpath = sprintf(\"%vvolumes[%v].hostPath.path\", [begginingOfPath, format_int(i, 10)])\n}\n\nisDangerousHostPath(volume, begginingOfPath, i) = path {\n    startswith(volume.hostPath.path, \"/var\")\n\tpath = sprintf(\"%vvolumes[%v].hostPath.path\", [begginingOfPath, format_int(i, 10)])\n}"
                }
            ]
        },
        {
            "name": "Instance Metadata API",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Discovery"
                ]
            },
            "description": "Attackers who gain access to a container, may query the metadata API service for getting information about the underlying node. This control checks if there is access from the nodes to cloud providers instance metadata services.",
            "remediation": "Disable metadata services for pods in cloud provider settings.",
            "id": "C-0052",
            "long_description": "Cloud providers provide instance metadata service for retrieving information about the virtual machine, such as network configuration, disks, and SSH public keys. This service is accessible to the VMs via a non-routable IP address that can be accessed from within the VM only. Attackers who gain access to a container, may query the metadata API service for getting information about the underlying node. For example, in Azure, the following request would retrieve all the metadata information of an instance: http:///metadata/instance?api-version=2019-06-01\\n\\n",
            "test": "Check which nodes have access to instance metadata services. The check is for AWS, GCP and Azure.",
            "controlID": "C-0052",
            "baseScore": 4.0,
            "rules": [
                {
                    "name": "instance-metadata-api-access",
                    "attributes": {
                        "m$K8sThreatMatrix": "Credential Access::Instance Metadata API",
                        "armoBuiltin": true,
                        "armoOpa": "true"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "nodes"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "Checks if there is access from the nodes to cloud prividers instance metadata services",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n# Check for images from blacklisted repos\n\nmetadata_azure(z) = http.send({\n\t\"url\": \"http://169.254.169.254/metadata/instance?api-version=2020-09-01\",\n\t\"method\": \"get\",\n\t\"headers\": {\"Metadata\": \"true\"},\n\t\"raise_error\": true,\t\n})\n\nmetadata_gcp(z) = http.send({\n\t\"url\": \"http://169.254.169.254/computeMetadata/v1/?alt=json&recursive=true\",\n\t\"method\": \"get\",\n\t\"headers\": {\"Metadata-Flavor\": \"Google\"},\n\t\"raise_error\": true,\t\n})\n\nmetadata_aws(z) = metadata_object { \n\thostname := http.send({\n\t\"url\": \"http://169.254.169.254/latest/meta-data/local-hostname\",\n\t\"method\": \"get\",\n\t\"raise_error\": true,\t\n    })\n\tmetadata_object := {\n\t\t\"raw_body\": hostname.raw_body,\n\t\t\"hostname\" : hostname.raw_body,\n\t\t\"status_code\" : hostname.status_code\n\t}\n}\n\nazure_metadata[msga] {\t\n\tmetadata_object := metadata_azure(\"aaa\")\n\tmetadata_object.status_code == 200\n\tnode_name := metadata_object.body.compute.name\n\tnodes := input[_]\n\tnodes.metadata.name == node_name\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Node '%s' has access to Instance Metadata Services of Azure.\", [node_name]),\n\t\t\"alert\": true,\n\t\t\"prevent\": false,\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8SApiObjects\": [nodes],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"azureMetadata\" : [metadata_object.body]\n\t\t\t}\n\t\t}\n\t}\n}\n\ngcp_metadata[msga] {\t\n\tmetadata_object := metadata_gcp(\"aaa\")\n\tmetadata_object.status_code == 200\n\tnode_name := metadata_object.body.instance.hostname\n\tnodes := input[_]\n\tnodes.metadata.name == node_name\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Node '%s' has access to Instance Metadata Services of GCP.\", [node_name]),\n\t\t\"alert\": true,\n\t\t\"prevent\": false,\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8SApiObjects\": [nodes],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"gcpMetadata\" : [metadata_object.raw_body]\n\t\t\t}\n\t\t}\n\t}\n}\n\naws_metadata[msga] {\t\n\tmetadata_object := metadata_aws(\"aaa\")\n\tmetadata_object.status_code == 200\n\tnode_name := metadata_object.hostname\n\tnodes := input[_]\n\tnodes.metadata.name == node_name\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Node '%s' has access to Instance Metadata Services of AWS.\", [node_name]),\n\t\t\"alert\": true,\n\t\t\"prevent\": false,\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8SApiObjects\": [nodes],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"awsMetadata\" : [metadata_object.raw_body]\n\t\t\t}\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Kubernetes CronJob",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Persistence"
                ]
            },
            "description": "Attackers may use Kubernetes CronJob for scheduling execution of malicious code that would run as a POD in the cluster. This control lists all the CronJobs that exist in the cluster for the user to approve.",
            "remediation": "Watch Kubernetes CronJobs and make sure they are legitimate.",
            "id": "C-0026",
            "long_description": "Kubernetes Job is a controller that creates one or more pods and ensures that a specified number of them successfully terminate. Kubernetes Job can be used to run containers that perform finite tasks for batch jobs. Kubernetes CronJob is used to schedule Jobs. Attackers may use Kubernetes CronJob for scheduling execution of malicious code that would run as a container in the cluster.",
            "test": "We list all CronJobs that exist in cluster for the user to approve.",
            "controlID": "C-0026",
            "baseScore": 3.0,
            "rules": [
                {
                    "name": "rule-deny-cronjobs",
                    "attributes": {
                        "m$K8sThreatMatrix": "Persistence::Kubernetes Cronjob",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "CronJob"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "determines if it's cronjob",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n# alert cronjobs\n\n#handles cronjob\ndeny[msga] {\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjobs are defined: %v\", [wl.metadata.name]),\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n"
                }
            ]
        },
        {
            "name": "List Kubernetes secrets",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Credential access"
                ],
                "rbacQuery": "Show who can access secrets"
            },
            "description": "Attackers who have permissions to access secrets can access sensitive information that might include credentials to various services. This control determines which user, group or service account can list/get secrets.",
            "remediation": "Monitor and approve list of users, groups and service accounts that can access secrets. Use exception mechanism to prevent repetitive the notifications.",
            "id": "C-0015",
            "long_description": "A Kubernetes secret is an object that lets users store and manage sensitive information, such as passwords and connection strings in the cluster. Secrets can be consumed by reference in the pod configuration. Attackers who have permissions to retrieve the secrets from the API server (by using the pod service account, for example) can access sensitive information that might include credentials to various services.",
            "test": "Alerting on users  which have get/list/watch RBAC permissions on secrets. ",
            "controlID": "C-0015",
            "baseScore": 7.0,
            "example": "@controls/examples/c015.yaml",
            "rules": [
                {
                    "name": "rule-can-list-get-secrets",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users can list/get secrets",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n\n# fails if user can list/get secrets \n#RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canViewSecretsResource(rule)\n    canViewSecretsVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can read secrets\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can list/get secrets \n#RoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canViewSecretsResource(rule)\n    canViewSecretsVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can read secrets\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [path],\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# fails if user can list/get secrets \n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canViewSecretsResource(rule)\n    canViewSecretsVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can read secrets\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"get\")\n}\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"list\")\n}\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"watch\")\n}\n\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"*\")\n}\n\n\ncanViewSecretsResource(rule) {\n    cautils.list_contains(rule.resources,\"secrets\")\n}\n\ncanViewSecretsResource(rule) {\n    isApiGroup(rule)\n    cautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}"
                },
                {
                    "name": "rule-can-list-get-secrets-v1",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
                        "armoBuiltin": true,
                        "resourcesAggregator": "subject-role-rolebinding",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users can list/get secrets",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can list/get secrets \ndeny[msga] {\n    subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"get\", \"list\", \"watch\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"secrets\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can read secrets\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": finalpath,\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}"
                }
            ]
        },
        {
            "name": "Mount service principal",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Credential Access"
                ]
            },
            "description": "When a cluster is deployed in the cloud, in some cases attackers can leverage their access to a container in the cluster to gain cloud credentials. This control determines if any workload contains a hostPath volume.",
            "example": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pd\nspec:\n  containers:\n  - image: k8s.gcr.io/test-webserver\n    name: test-container\n    volumeMounts:\n    - mountPath: /test-pd\n      name: test-volume\n  volumes:\n  - name: test-volume\n    hostPath: # This field triggers failure!\n      path: /data\n      type: Directory\n",
            "remediation": "Refrain from using host path mount.",
            "id": "C-0020",
            "long_description": "When the cluster is deployed in the cloud, in some cases attackers can leverage their access to a container in the cluster to gain cloud credentials. For example, in AKS each node contains service principal credential.",
            "test": "Check which workloads have hostPath volumes to known cloud credentials files in node, like \u201c/etc/kubernetes/azure.json\u201d for Azure.",
            "controlID": "C-0020",
            "baseScore": 4.0,
            "rules": [
                {
                    "name": "alert-any-hostpath",
                    "attributes": {
                        "m$K8sThreatMatrix": "Privilege Escalation::hostPath mount",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "determines if any workload contains a hostPath volume",
                    "remediation": "Try to refrain from using hostPath mounts",
                    "ruleQuery": "",
                    "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    volumes := pod.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.\"\n\tresult  := isDangerousHostPath(volume, begginingOfPath, i)\n    podname := pod.metadata.name\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod: %v has: %v as hostPath volume\", [podname, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    volumes := wl.spec.template.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result  := isDangerousHostPath(volume, begginingOfPath, i)\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n#handles CronJobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    volumes := wl.spec.jobTemplate.spec.template.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n    result  := isDangerousHostPath(volume, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\nisDangerousHostPath(volume, begginingOfPath, i) = path {\n    startswith(volume.hostPath.path, \"/etc\")\n\tpath = sprintf(\"%vvolumes[%v].hostPath.path\", [begginingOfPath, format_int(i, 10)])\n}\n\nisDangerousHostPath(volume, begginingOfPath, i) = path {\n    startswith(volume.hostPath.path, \"/var\")\n\tpath = sprintf(\"%vvolumes[%v].hostPath.path\", [begginingOfPath, format_int(i, 10)])\n}"
                }
            ]
        },
        {
            "name": "Privileged container",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Privilege escalation"
                ]
            },
            "description": "Potential attackers may gain access to privileged containers and inherit access to the host resources. Therefore, it is not recommended to deploy privileged containers unless it is absolutely necessary. This control identifies all the privileged Pods.",
            "example": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged\nspec:\n  containers:\n    - name: pause\n      image: k8s.gcr.io/pause\n      securityContext:\n          privileged: true # This field triggers failure!\n",
            "remediation": "Remove privileged capabilities by setting the securityContext.privileged to false. If you must deploy a Pod as privileged, add other restriction to it, such as network policy, Seccomp etc and still remove all unnecessary capabilities. Use the exception mechanism to remove unnecessary notifications.",
            "id": "C-0057",
            "long_description": "A privileged container is a container that has all the capabilities of the host machine, which lifts all the limitations regular containers have. Practically, this means that privileged containers can do almost every action that can be performed directly on the host. Attackers who gain access to a privileged container or have permissions to create a new privileged container (by using the compromised pod\u2019s service account, for example), can get access to the host\u2019s resources.",
            "test": "Check in POD spec if securityContext.privileged == true, if so raise an alert.",
            "controlID": "C-0057",
            "baseScore": 8.0,
            "rules": [
                {
                    "name": "rule-privilege-escalation",
                    "attributes": {
                        "m$K8sThreatMatrix": "Privilege Escalation::privileged container",
                        "mitre": "Privilege Escalation",
                        "mitreCode": "TA0004",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "determines if pods/deployments defined as privileged true",
                    "remediation": "avoid defining pods as privilleged",
                    "ruleQuery": "",
                    "rule": "package armo_builtins\n# Deny mutating action unless user is in group owning the resource\n\n\n#privileged pods\ndeny[msga] {\n\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n\tpath := isPrivilegedContainer(container, i, begginingOfPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following pods are defined as privileged: %v\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": path,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n     }\n}\n\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n\tpath := isPrivilegedContainer(container, i, begginingOfPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is defined as privileged:\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": path,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n#handles cronjob\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tpath := isPrivilegedContainer(container, i, begginingOfPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjobs are defined as privileged: %v\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": path,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n\n# Only SYS_ADMIN capabilite\nisPrivilegedContainer(container, i, begginingOfPath) = path {\n\tnot container.securityContext.privileged == true\n\tpath = [sprintf(\"%vcontainers[%v].securityContext.capabilities.add[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) | capabilite = container.securityContext.capabilities.add[k]; capabilite == \"SYS_ADMIN\"]\n\tcount(path) > 0\n}\n\n# Only securityContext.privileged == true\nisPrivilegedContainer(container, i, begginingOfPath) = path {\n\tcontainer.securityContext.privileged == true\n\tpath1 = [sprintf(\"%vcontainers[%v].securityContext.capabilities.add[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) | capabilite = container.securityContext.capabilities.add[k]; capabilite == \"SYS_ADMIN\"]\n\tcount(path1) < 1\n\tpath = [sprintf(\"%vcontainers[%v].securityContext.privileged\", [begginingOfPath, format_int(i, 10)])]\n}\n\n# SYS_ADMIN capabilite && securityContext.privileged == true\nisPrivilegedContainer(container, i, begginingOfPath) = path {\n\tpath1 = [sprintf(\"%vcontainers[%v].securityContext.capabilities.add[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) | capabilite = container.securityContext.capabilities.add[k]; capabilite == \"SYS_ADMIN\"]\n\tcount(path1) > 0\n\tcontainer.securityContext.privileged == true\n\tpath = array.concat(path1, [sprintf(\"%vcontainers[%v].securityContext.privileged\", [begginingOfPath, format_int(i, 10)])])\n}"
                }
            ]
        },
        {
            "name": "SSH server running inside container",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Execution"
                ]
            },
            "description": "An SSH server that is running inside a container may be used by attackers to get remote access to the container. This control checks if pods have an open SSH port (22/2222).",
            "remediation": "Remove SSH from the container image or limit the access to the SSH server using network policies.",
            "id": "C-0042",
            "long_description": "SSH server that is running inside a container may be used by attackers. If attackers gain valid credentials to a container, whether by brute force attempts or by other methods (such as phishing), they can use it to get remote access to the container by SSH.",
            "test": "Check if service connected to some workload has an SSH port (22/2222). If so we raise an alert. ",
            "controlID": "C-0042",
            "baseScore": 8.0,
            "rules": [
                {
                    "name": "rule-can-ssh-to-pod",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Execution::SSH server running inside container",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod",
                                "Service"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "denies pods with SSH ports opened(22/222)",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n# input: pod\n# apiversion: v1\n# does:\treturns the external facing services of that pod\n\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tpodns := pod.metadata.namespace\n\tpodname := pod.metadata.name\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n    path := \"metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == podns\n\tservice.spec.selector == filtered_labels\n    \n\thasSSHPorts(service)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod %v/%v exposed by SSH services: %v\", [podns, podname, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod,service]\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tlabels := wl.spec.template.metadata.labels\n    path := \"spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl,service]\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n    path := \"spec.jobTemplate.spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl,service]\n\t\t}\n     }\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 2222\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 2222\n}\n"
                },
                {
                    "name": "rule-can-ssh-to-pod-v1",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Execution::SSH server running inside container",
                        "armoBuiltin": true,
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod",
                                "Service"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "denies pods with SSH ports opened(22/222)",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n# input: pod\n# apiversion: v1\n# does:\treturns the external facing services of that pod\n\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tpodns := pod.metadata.namespace\n\tpodname := pod.metadata.name\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n    path := \"metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == podns\n\tservice.spec.selector == filtered_labels\n    \n\thasSSHPorts(service)\n\n\twlvector = {\"name\": pod.metadata.name,\n\t\t\t\t\"namespace\": pod.metadata.namespace,\n\t\t\t\t\"kind\": pod.kind,\n\t\t\t\t\"relatedObjects\": service}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod %v/%v exposed by SSH services: %v\", [podns, podname, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n    }\n}\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tlabels := wl.spec.template.metadata.labels\n    path := \"spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n    path := \"spec.jobTemplate.spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 2222\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 2222\n}\n",
                    "resourceEnumerator": "package armo_builtins\n\n# input: pod\n# apiversion: v1\n# does:\treturns the external facing services of that pod\n\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tpodns := pod.metadata.namespace\n\tpodname := pod.metadata.name\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n    path := \"metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == podns\n\tservice.spec.selector == filtered_labels\n    \n\thasSSHPorts(service)\n\n\twlvector = {\"name\": pod.metadata.name,\n\t\t\t\t\"namespace\": pod.metadata.namespace,\n\t\t\t\t\"kind\": pod.kind,\n\t\t\t\t\"relatedObjects\": service}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod %v/%v exposed by SSH services: %v\", [podns, podname, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n    }\n}\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tlabels := wl.spec.template.metadata.labels\n    path := \"spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n    path := \"spec.jobTemplate.spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 2222\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 2222\n}\n"
                }
            ]
        },
        {
            "name": "Vulnerable application",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Initial Access"
                ]
            },
            "description": "Running a vulnerable application in a cluster can enable an attacker initial access to the cluster. This control determines if pods/deployments have vulnerable images using ARMO vulnerability scan (must run vulnerability scan before running posture scan). ",
            "remediation": "Upgrade your containers to not vulnerble versions or use ARMO runtime protection (sign/verify the workload in the runtime).",
            "id": "C-0024",
            "long_description": "Running a public-facing vulnerable application in a cluster can enable initial access to the cluster. A container that runs an application that is vulnerable to remote code execution vulnerability (RCE) may be exploited. If service account is mounted to the container (default behavior in Kubernetes), the attacker will be able to send requests to the API server using this service account credentials.",
            "test": "Searching the image from pod spec in the vulnerability scan database, if there is at least one high vulnerability we raise an alert.",
            "controlID": "C-0024",
            "baseScore": 6.0,
            "rules": [
                {
                    "name": "deny-vuln-image-pods",
                    "attributes": {
                        "m$K8sThreatMatrix": "Initial Access::Application Vulnerability",
                        "mitre": "Exploit Public-Facing Application",
                        "mitreCode": "T1190",
                        "armoBuiltin": true,
                        "armoOpa": "true"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod",
                                "services"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines if pods/deployments has vulnerable image",
                    "remediation": "Isolate such deployments in sandboxes if possible. Otherwise, keep scanning frequently for in case a patch will be available - MAKE SURE it has least privileges as necessary!",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n    \ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == pod.metadata.namespace\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,filtered_labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"pod %v/%v has vulnerabilities\", [pod.metadata.namespace,pod.metadata.name]),\n        \"alertScore\": 2,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t},\n\t\t\"externalObjects\": {\n\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t}\n    }\n}\n\n# covers most workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\n\tlabels := wl.spec.template.metadata.labels\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"%v: %v/%v has vulnerabilities\", [wl.kind, wl.metadata.namespace, wl.metadata.name]),\n        \"alertScore\": 2,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t},\n\t\t\"externalObjects\": {\n\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t}\n    }\n}\n\n# covers cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\t\n\n    msga := {\n        \"alertMessage\": sprintf(\"%v: %v/%v has vulnerabilities\", [wl.kind, wl.metadata.namespace, wl.metadata.name]),\n        \"alertScore\": 2,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t},\n\t\t\"externalObjects\": {\n\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t}\n    }\n}\n\n\n#treat as potentially critical\nis_unsafe_image(scanresult) {\n\tscanresult.numOfUnknownSeverity > 0\n}\nis_unsafe_image(scanresult) {\n\tscanresult.numOfNegligibleSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfLowSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfMeduiumSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfHighSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfCriticalSeverity > 0\n}\n"
                }
            ]
        },
        {
            "name": "Writable hostPath mount",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Persistence",
                    "Lateral Movement"
                ]
            },
            "description": "Mounting host directory to the container can be used by attackers to get access to the underlying host and gain persistence.",
            "remediation": "Refrain from using the hostPath mount or use the exception mechanism to remove unnecessary notifications.",
            "id": "C-0045",
            "long_description": "hostPath volume mounts a directory or a file from the host to the container. Attackers who have permissions to create a new container in the cluster may create one with a writable hostPath volume and gain persistence on the underlying host. For example, the latter can be achieved by creating a cron job on the host.",
            "test": "Checking in POD spec if there is a hostPath volume, if it has the section mount.readOnly == false (or doesn\u2019t exist) we raise an alert.",
            "controlID": "C-0045",
            "baseScore": 8.0,
            "example": "@controls/examples/c045.yaml",
            "rules": [
                {
                    "name": "alert-rw-hostpath",
                    "attributes": {
                        "m$K8sThreatMatrix": "Persistance::Writable hostPath mount, Lateral Movement::Writable volume mounts on the host",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "CronJob",
                                "Pod"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        },
                        {
                            "packageName": "kubernetes.api.client"
                        }
                    ],
                    "description": "determines if any workload contains a hostPath volume with rw permissions",
                    "remediation": "Set the readOnly field of the mount to true",
                    "ruleQuery": "",
                    "rule": "package armo_builtins\n\n# Fails if container has a hostPath volume which is not readOnly\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    volumes := pod.spec.volumes\n    volume := volumes[_]\n    volume.hostPath\n\tcontainer := pod.spec.containers[i]\n\tvolumeMount := container.volumeMounts[k]\n\tvolumeMount.name == volume.name\n\tbegginingOfPath := \"spec.\"\n\tresult := isRWMount(volumeMount, begginingOfPath,  i, k)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n    podname := pod.metadata.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod: %v has: %v as hostPath volume\", [podname, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    volumes := wl.spec.template.spec.volumes\n    volume := volumes[_]\n    volume.hostPath\n\tcontainer := wl.spec.template.spec.containers[i]\n\tvolumeMount := container.volumeMounts[k]\n\tvolumeMount.name == volume.name\n\tbegginingOfPath := \"spec.template.spec.\"\n\tresult := isRWMount(volumeMount, begginingOfPath,  i, k)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t\n\t}\n}\n\n#handles CronJobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    volumes := wl.spec.jobTemplate.spec.template.spec.volumes\n    volume := volumes[_]\n    volume.hostPath\n\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tvolumeMount := container.volumeMounts[k]\n\tvolumeMount.name == volume.name\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tresult := isRWMount(volumeMount, begginingOfPath,  i, k) \n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\n\tmsga := {\n\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\"packagename\": \"armo_builtins\",\n\t\"alertScore\": 7,\n\t\"fixPaths\": fixedPath,\n\t\"failedPaths\": failedPath,\n\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\ngetFailedPath(paths) = [paths[0]] {\n\tpaths[0] != \"\"\n} else = []\n\n\ngetFixedPath(paths) = [paths[1]] {\n\tpaths[1] != \"\"\n} else = []\n\n\nisRWMount(mount, begginingOfPath,  i, k) =  [failedPath, fixPath] {\n\tnot mount.readOnly == true\n \tnot mount.readOnly == false\n\tfailedPath = \"\"\n    fixPath = {\"path\": sprintf(\"%vcontainers[%v].volumeMounts[%v].readOnly\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]), \"value\":\"true\"}\n}\n\nisRWMount(mount, begginingOfPath,  i, k) =  [failedPath, fixPath] {\n  \tmount.readOnly == false\n  \tfailedPath = sprintf(\"%vcontainers[%v].volumeMounts[%v].readOnly\", [begginingOfPath, format_int(i, 10), format_int(k, 10)])\n    fixPath = \"\"\n} "
                }
            ]
        },
        {
            "name": "Malicious admission controller (mutating)",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Persistence"
                ]
            },
            "description": "Attackers may use mutating webhooks to intercept and modify all the resources in the cluster. This control lists all mutating webhook configurations that must be verified.",
            "remediation": "Ensure all the webhooks are necessary. Use exception mechanism to prevent repititive notifications.",
            "id": "C-0039",
            "controlID": "C-0039",
            "baseScore": 10.0,
            "rules": [
                {
                    "name": "list-all-mutating-webhooks",
                    "attributes": {
                        "m$K8sThreatMatrix": "Persistence::Malicious admission controller",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "MutatingWebhookConfiguration"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "Returns mutating webhook configurations to be verified",
                    "remediation": "Analyze webhook for malicious behavior",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n\ndeny [msga] {\n    mutatingwebhooks := [mutatingwebhook | mutatingwebhook = input[_]; mutatingwebhook.kind == \"MutatingWebhookConfiguration\"]\n    mutatingwebhook := mutatingwebhooks[_]\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following mutating webhook configuration should be checked %v.\", [mutatingwebhook.metadata.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [mutatingwebhook]\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Malicious admission controller (validating)",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Credential access"
                ]
            },
            "description": "Attackers can use validating webhooks to intercept and discover all the resources in the cluster. This control lists all the validating webhook configurations that must be verified.",
            "remediation": "Ensure all the webhooks are necessary. Use exception mechanism to prevent repititive notifications.",
            "id": "C-0036",
            "controlID": "C-0036",
            "baseScore": 7.0,
            "rules": [
                {
                    "name": "list-all-validating-webhooks",
                    "attributes": {
                        "m$K8sThreatMatrix": "Credential Access::Malicious admission controller",
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "ValidatingWebhookConfiguration"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "Returns validating webhook configurations to be verified",
                    "remediation": "Analyze webhook for malicious behavior",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n\ndeny [msga] {\n    admissionwebhooks := [admissionwebhook | admissionwebhook = input[_]; admissionwebhook.kind == \"ValidatingWebhookConfiguration\"]\n    admissionwebhook := admissionwebhooks[_]\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following validating webhook configuration should be checked %v.\", [admissionwebhook.metadata.name]),\n\t\t\"alertScore\": 6,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [\"\"],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [admissionwebhook]\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Delete Kubernetes events",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Defense evasion"
                ],
                "rbacQuery": "Show who can delete k8s events"
            },
            "description": "Attackers may delete Kubernetes events to avoid detection of their activity in the cluster. This control identifies all the subjects that can delete Kubernetes events.",
            "remediation": "You should follow the least privilege principle. Minimize the number of subjects who can delete Kubernetes events. Avoid using these subjects in the daily operations.",
            "id": "C-0031",
            "long_description": "A Kubernetes event is a Kubernetes object that logs state changes and failures of the resources in the cluster. Example events are a container creation, an image pull, or a pod scheduling on a node. Kubernetes events can be very useful for identifying changes that occur in the cluster. Therefore, attackers may want to delete these events (e.g., by using: \u201ckubectl delete events\u2013all\u201d) in an attempt to avoid detection of their activity in the cluster.",
            "test": "List who has delete/deletecollection RBAC permissions on events.",
            "controlID": "C-0031",
            "baseScore": 4.0,
            "example": "@controls/examples/c031.yaml",
            "rules": [
                {
                    "name": "rule-can-delete-k8s-events",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Defense Evasion::Delete K8S events",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users can delete events",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can delete events\n#RoleBinding to Role\ndeny [msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteEventsResource(rule)\n    canDeleteEventsVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete events\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can delete events\n#RoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteEventsResource(rule)\n    canDeleteEventsVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete events\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can delete events\n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteEventsResource(rule)\n    canDeleteEventsVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete events\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\ncanDeleteEventsResource(rule) {\n cautils.list_contains(rule.resources,\"events\")\n}\ncanDeleteEventsResource(rule) {\n isApiGroup(rule)\n cautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\ncanDeleteEventsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"delete\")\n}\n\ncanDeleteEventsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"deletecollection\")\n}\n\ncanDeleteEventsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"*\")\n}"
                },
                {
                    "name": "rule-can-delete-k8s-events-v1",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Defense Evasion::Delete K8S events",
                        "armoBuiltin": true,
                        "resourcesAggregator": "subject-role-rolebinding",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users can delete events",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can delete events\ndeny [msga] {\n    subjectVector := input[_]\n    role := subjectVector.relatedObjects[i]\n    rolebinding := subjectVector.relatedObjects[j]\n    endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n    endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n    rule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"delete\", \"deletecollection\", \"*\"]\n    verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"events\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n\t\n\n    msga := {\n        \"alertMessage\": sprintf(\"Subject: %v-%v can delete events\", [subjectVector.kind, subjectVector.name]),\n        \"alertScore\": 3,\n        \"packagename\": \"armo_builtins\",\n        \"failedPaths\": finalpath,\n        \"fixPaths\": [],\n        \"alertObject\": {\n            \"k8sApiObjects\": [],\n            \"externalObjects\": subjectVector\n        }\n    }\n}\n"
                }
            ]
        },
        {
            "name": "CoreDNS poisoning",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Lateral Movement"
                ]
            },
            "description": "If attackers have permissions to modify the coredns ConfigMap they can change the behavior of the cluster\u2019s DNS, poison it, and override the network identity of other services. This control identifies all subjects allowed to update the 'coredns' configmap.",
            "remediation": "You should follow the least privilege principle. Monitor and approve all the subjects allowed to modify the 'coredns' configmap. It is also recommended to remove this permission from the users/service accounts used in the daily operations.",
            "id": "C-0037",
            "long_description": "CoreDNS is a modular Domain Name System (DNS) server written in Go, hosted by Cloud Native Computing Foundation (CNCF). CoreDNS is the main DNS service that is being used in Kubernetes. The configuration of CoreDNS can be modified by a file named corefile. In Kubernetes, this file is stored in a ConfigMap object, located at the kube-system namespace. If attackers have permissions to modify the ConfigMap, for example by using the container\u2019s service account, they can change the behavior of the cluster\u2019s DNS, poison it, and take the network identity of other services.",
            "test": "Check who has update/patch RBAC permissions on \u2018coredns\u2019 configmaps, or to all configmaps.",
            "controlID": "C-0037",
            "baseScore": 5.0,
            "rules": [
                {
                    "name": "rule-can-update-configmap",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Lateral Movement::CoreDNS poisoning",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding",
                                "ConfigMap"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users can update/patch the 'coredns' configmap",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n\n# Fails if user can modify all configmaps, or if he can modify the 'coredns' configmap (default for coredns)\n#RoleBinding to Role\ndeny [msga] {\n     configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n     configmap := configmaps[_]\n     configmap.metadata.name == \"coredns\"\n\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\n    canModifyConfigMapResource(rule)\n    canModifyConfigMapVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n    rolebinding.metadata.namespace == \"kube-system\"\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can modify 'coredns' configmap\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n# Fails if user can modify all configmaps, or if he can modify the 'coredns' configmap (default for coredns)\n# RoleBinding to ClusterRole\ndeny[msga] {\n     configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n     configmap := configmaps[_]\n     configmap.metadata.name == \"coredns\"\n\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canModifyConfigMapResource(rule)\n    canModifyConfigMapVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n    rolebinding.metadata.namespace == \"kube-system\"\n\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can modify 'coredns' configmap\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n\n}\n\n\n# Fails if user can modify all configmaps, or if he can modify the 'coredns' configmap (default for coredns)\n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n     configmap := configmaps[_]\n     configmap.metadata.name == \"coredns\"\n\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canModifyConfigMapResource(rule)\n    canModifyConfigMapVerb(rule)\n\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can modify 'coredns'  configmap\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n\n\n\n  canModifyConfigMapResource(rule) {\n        not rule.resourceNames\n       cautils.list_contains(rule.resources,\"configmaps\")\n  }\n\n  canModifyConfigMapResource(rule) {\n       not rule.resourceNames\n       isApiGroup(rule)\n       cautils.list_contains(rule.resources,\"*\")\n  }\n\n   canModifyConfigMapResource(rule) {\n       cautils.list_contains(rule.resources,\"configmaps\")\n       cautils.list_contains(rule.resourceNames,\"coredns\")\n   }\n\n   canModifyConfigMapVerb(rule) {\n       cautils.list_contains(rule.verbs,\"update\")\n   }\n\n\n   canModifyConfigMapVerb(rule) {\n       cautils.list_contains(rule.verbs,\"patch\")\n   }\n\n      canModifyConfigMapVerb(rule) {\n       cautils.list_contains(rule.verbs,\"*\")\n   }\n\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}"
                },
                {
                    "name": "rule-can-update-configmap-v1",
                    "attributes": {
                        "microsoftK8sThreatMatrix": "Lateral Movement::CoreDNS poisoning",
                        "armoBuiltin": true,
                        "resourcesAggregator": "subject-role-rolebinding",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        }
                    ],
                    "description": "determines which users can update/patch the 'coredns' configmap",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Fails if user can modify all configmaps\ndeny [msga] {\n     subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n     rule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"update\", \"patch\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"configmaps\", \"*\"]\n     not rule.resourceNames\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can modify 'coredns' configmap\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": finalpath,\n\t\t  \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}\n\n\n# Fails if user  can modify the 'coredns' configmap (default for coredns)\ndeny [msga] {\n     subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n     rule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"update\", \"patch\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"configmaps\", \"*\"]\n     cautils.list_contains(rule.resourceNames,\"coredns\")\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can modify 'coredns' configmap\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": finalpath,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}\n"
                }
            ]
        },
        {
            "name": "Data Destruction",
            "attributes": {
                "armoBuiltin": true,
                "microsoftMitreColumns": [
                    "Impact"
                ],
                "rbacQuery": "Data destruction"
            },
            "description": "Attackers may attempt to destroy data and resources in the cluster. This includes deleting deployments, configurations, storage, and compute resources. This control identifies all subjects that can delete resources.",
            "remediation": "You should follow the least privilege principle and minimize the number of subjects that can delete resources.",
            "id": "C-0007",
            "long_description": "Attackers may attempt to destroy data and resources in the cluster. This includes deleting deployments, configurations, storage, and compute resources.",
            "test": "Check which subjects have delete/deletecollection RBAC permissions on workloads.",
            "controlID": "C-0007",
            "baseScore": 10.0,
            "example": "@controls/examples/c007.yaml",
            "rules": [
                {
                    "name": "rule-excessive-delete-rights",
                    "attributes": {
                        "m$K8sThreatMatrix": "Impact::Data Destruction",
                        "armoBuiltin": true,
                        "useUntilKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if user can delete important resources",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "resourceCount": "subjects",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n\n# fails if user can can delete important resources\n#RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteResource(rule)\n    canDeleteVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete important resources\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can can delete important resources\n#RoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteResource(rule)\n    canDeleteVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete important resources\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# fails if user can can delete important resources\n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteResource(rule)\n    canDeleteVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete important resources\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\ncanDeleteVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"delete\")\n}\n\ncanDeleteVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"deletecollection\")\n}\n\ncanDeleteVerb(rule)  {\n\tcautils.list_contains(rule.verbs, \"*\")\n}\n\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"secrets\")\n}\ncanDeleteResource(rule)  {\n\tcautils.list_contains(rule.resources, \"pods\")\n}\ncanDeleteResource(rule)  {\n\tcautils.list_contains(rule.resources, \"services\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"deployments\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"replicasets\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"daemonsets\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"statefulsets\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"jobs\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"cronjobs\")\n}\ncanDeleteResource(rule)  {\n    isApiGroup(rule)\n\tcautils.list_contains(rule.resources, \"*\")\n}\n\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"apps\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"batch\"\n}\n\n"
                },
                {
                    "name": "rule-excessive-delete-rights-v1",
                    "attributes": {
                        "m$K8sThreatMatrix": "Impact::Data Destruction",
                        "armoBuiltin": true,
                        "resourcesAggregator": "subject-role-rolebinding",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Role",
                                "ClusterRole",
                                "ClusterRoleBinding",
                                "RoleBinding"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "fails if user can delete important resources",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can can delete important resources\ndeny[msga] {\n    subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"delete\", \"deletecollection\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\", \"apps\", \"batch\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"secrets\", \"pods\", \"services\", \"deployments\", \"replicasets\", \"daemonsets\", \"statefulsets\", \"jobs\",\"cronjobs\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can delete important resources\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": finalpath,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}"
                }
            ]
        },
        {
            "name": "CVE-2021-25741 - Using symlink for arbitrary host file system access.",
            "attributes": {
                "armoBuiltin": true
            },
            "description": "A user may be able to create a container with subPath or subPathExpr volume mounts to access files & directories anywhere on the host filesystem. Following Kubernetes versions are affected: v1.22.0 - v1.22.1, v1.21.0 - v1.21.4, v1.20.0 - v1.20.10, version v1.19.14 and lower. This control checks the vulnerable versions and the actual usage of the subPath feature in all Pods in the cluster. If you want to learn more about the CVE, please refer to the CVE link: https://nvd.nist.gov/vuln/detail/CVE-2021-25741",
            "remediation": "To mitigate this vulnerability without upgrading kubelet, you can disable the VolumeSubpath feature gate on kubelet and kube-apiserver, or remove any existing Pods using subPath or subPathExpr feature.",
            "id": "C-0058",
            "controlID": "C-0058",
            "baseScore": 6.0,
            "rules": [
                {
                    "name": "Symlink-Exchange-Can-Allow-Host-Filesystem-Access",
                    "attributes": {
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ReplicaSet",
                                "DaemonSet",
                                "StatefulSet",
                                "Job",
                                "Pod",
                                "CronJob",
                                "Node"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "A user may be able to create a container with subPath volume mounts to access files & directories outside of the volume, including on the host filesystem. This was affected at the following versions: v1.22.0 - v1.22.1, v1.21.0 - v1.21.4, v1.20.0 - v1.20.10, version v1.19.14 and lower. ",
                    "remediation": "To mitigate this vulnerability without upgrading kubelet, you can disable the VolumeSubpath feature gate on kubelet and kube-apiserver, and remove any existing Pods making use of the feature.",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n    finalpath := isSubPathContainer(container, i, begginingOfPath)\n\n\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25741. You have a Node with a vulnerable version and the following container : %v in pod : %v with subPath/subPathExpr\", [container.name, pod.metadata.name]),\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [pod]},\n\t\t\t\"failedPaths\": finalpath,\n\t\t\t\"fixPaths\": [],\n\t\t}\n}\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    finalpath := isSubPathContainer(container, i, begginingOfPath)\n       \n\tmsga := {\n\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25741. You have a Node with a vulnerable version and the following container : %v in %v : %v with subPath/subPathExpr\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": finalpath,\n\t\t\t\"fixPaths\": [],\n\t\t}\n}\n\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n    finalpath := isSubPathContainer(container, i, begginingOfPath)\n    \n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25741. You have a Node with a vulnerable version and the following container : %v in %v : %v with subPath/subPathExpr\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": finalpath,\n\t\t\t\"fixPaths\": [],\n\t\t}\n}\n\n\n\nisSubPathContainer(container, i, begginingOfPath) = path {\n\tpath = [sprintf(\"%vcontainers[%v].volumeMounts[%v].subPath\" ,[begginingOfPath, format_int(i, 10), format_int(j, 10)]) | volumeMount = container.volumeMounts[j];  volumeMount.subPath]\n\tcount(path) > 0\n}\n\nisVulnerableVersion(version)  {\n    version <=  \"v1.19.14\"\n}\n\nisVulnerableVersion(version){\n    version >= \"v1.22.0\"\n    version <= \"v1.22.1\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.21.0\"\n    version <= \"v1.21.4\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.20.0\"\n    version <= \"v1.20.9\"\n}\n\nisVulnerableVersion(version){\n\tversion == \"v1.20.10\"\n}\n\n\n",
                    "resourceEnumerator": "package armo_builtins\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n\tversionPath = \"status.nodeInfo.kubeletVersion\"\n    pod := input[_]\n    pod.kind == \"Pod\"\n\n\tmsga := {\n\t\t\t\"alertMessage\": \"\",\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [pod]},\n\t\t\t\"failedPaths\": [\"\"],\n\t}\n}\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n\tversionPath = \"status.nodeInfo.kubeletVersion\"\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n       \n\tmsga := {\n\t\"alertMessage\": \"\",\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": [\"\"],\n\t}\n}\n\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n\tversionPath = \"status.nodeInfo.kubeletVersion\"\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    \n\tmsga := {\n\t\t\"alertMessage\": \"\",\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": [\"\"],\n\t}\n}\n\n\nisVulnerableVersion(version)  {\n    version <=  \"v1.19.14\"\n}\n\nisVulnerableVersion(version){\n    version >= \"v1.22.0\"\n    version <= \"v1.22.1\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.21.0\"\n    version <= \"v1.21.4\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.20.0\"\n    version <= \"v1.20.9\"\n}\n\nisVulnerableVersion(version){\n\tversion == \"v1.20.10\"\n}"
                }
            ]
        },
        {
            "name": "CVE-2021-25742-nginx-ingress-snippet-annotation-vulnerability",
            "attributes": {
                "armoBuiltin": true
            },
            "description": "Security issue in ingress-nginx where a user that can create or update ingress objects can use the custom snippets feature to obtain all secrets in the cluster (see more at https://github.com/kubernetes/ingress-nginx/issues/7837)",
            "remediation": "To mitigate this vulnerability: 1. Upgrade to a version that allows mitigation (>= v0.49.1 or >= v1.0.1), 2. Set allow-snippet-annotations to false in your ingress-nginx ConfigMap based on how you deploy ingress-nginx",
            "test": "The control checks if the nginx-ingress-controller contains the ability to disable allowSnippetAnnotations and that indeed this feature is turned off",
            "id": "C-0059",
            "controlID": "C-0059",
            "baseScore": 5.0,
            "rules": [
                {
                    "name": "nginx-ingress-snippet-annotation-vulnerability",
                    "attributes": {
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Deployment",
                                "ConfigMap"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\ndeny[msga] {\n\tdeployment := input[_]\n\tdeployment.kind == \"Deployment\"\n\timage := deployment.spec.template.spec.containers[i].image\n\tisNginxImage(image)\n\tisTagImage(image)\n\tisVulnerable(image, deployment.metadata.namespace)\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25742. Deployment %v\", [deployment.metadata.name]),\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"fixPaths\":[],\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [deployment]},\n\t\t}\n}\n\n\t\nisNginxImage(image) {\n\tcontains(image, \"nginx-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-nginx\")\n}\n\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag <= \"v0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag  == \"v1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag <= \"v0.49\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag  == \"v1.0.0\"\n}\n\n###### without 'v'\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag <= \"0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag <= \"0.49\"\n}\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n    configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n\tconfigmapOnIngressNamespace := [configmap |  configmap= configmaps[_]; configmap.metadata.namespace == namespace]\n\tconfigMapsWithSnippet := [configmap |  configmap= configmapOnIngressNamespace[_];  configmap.data[\"allow-snippet-annotations\"] == \"false\"]\n\tcount(configMapsWithSnippet) < 1\n}\n\n\nisTagImage(image) {\n    reg := \":[\\\\w][\\\\w.-]{0,127}(\\/)?\"\n    version := regex.find_all_string_submatch_n(reg, image, -1)\n    v := version[_]\n    img := v[_]\n    not endswith(img, \"/\")\n}",
                    "resourceEnumerator": "package armo_builtins\n\ndeny[msga] {\n\tdeployment := input[_]\n\tdeployment.kind == \"Deployment\"\n\timage := deployment.spec.template.spec.containers[i].image\n\tisNginxImage(image)\n\tisTagImage(image)\n\tisVulnerable(image, deployment.metadata.namespace)\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25742. %v\", [deployment]),\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [deployment]},\n\t\t}\n}\n\n\t\nisNginxImage(image) {\n\tcontains(image, \"nginx-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-nginx\")\n}\n\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag <= \"v0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag  == \"v1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag <= \"v0.49\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag  == \"v1.0.0\"\n}\n\n###### without 'v'\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag <= \"0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag <= \"0.49\"\n}\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n    configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n\tconfigmapOnIngressNamespace := [configmap |  configmap= configmaps[_]; configmap.metadata.namespace == namespace]\n\tconfigMapsWithSnippet := [configmap |  configmap= configmapOnIngressNamespace[_];  configmap.data[\"allow-snippet-annotations\"] == \"false\"]\n\tcount(configMapsWithSnippet) < 1\n}\n\n\nisTagImage(image) {\n    reg := \":[\\\\w][\\\\w.-]{0,127}(\\/)?\"\n    version := regex.find_all_string_submatch_n(reg, image, -1)\n    v := version[_]\n    img := v[_]\n    not endswith(img, \"/\")\n}"
                }
            ]
        },
        {
            "name": "Audit logs enabled",
            "attributes": {
                "armoBuiltin": true
            },
            "description": "Audit logging is an important security feature in Kubernetes, it enables the operator to track requests to the cluster. It is important to use it so the operator has a record of events happened in Kubernetes",
            "remediation": "Turn on audit logging for your cluster. Look at the vendor guidlines for more details",
            "id": "C-0067",
            "long_description": "Audit logging is an important security feature in Kubernetes, it enables the operator to track requests to the cluster. It is important to use it so the operator has a record of events happened in Kubernetes",
            "test": "Reading the cluster descritpion from the managed cloud API (EKS, GKE), or the API server pod configuration for native K8s and checking if audit logging is enabled",
            "controlID": "C-0067",
            "baseScore": 3,
            "rules": [
                {
                    "name": "k8s-audit-logs-enabled-cloud",
                    "attributes": {
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [],
                            "apiVersions": [],
                            "resources": []
                        }
                    ],
                    "dynamicMatch": [
                        {
                            "apiGroups": [
                                "container.googleapis.com",
                                "eks.amazonaws.com"
                            ],
                            "apiVersions": [
                                "v1"
                            ],
                            "resources": [
                                "ClusterDescribe"
                            ]
                        }
                    ],
                    "relevantCloudProviders": [
                        "EKS",
                        "GKE"
                    ],
                    "ruleDependencies": [],
                    "description": "",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Check if audit logs is enabled for GKE\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"container.googleapis.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"gke\"\t\n\tconfig := clusterConfig.data\n\t\n    # If enableComponents is empty, it will disable logging\n    # https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#loggingcomponentconfig\n\tisLoggingDisabled(config)\n\tmsga := {\n\t\t\"alertMessage\": \"audit logs is disabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n\n# Check if audit logs is enabled for EKS\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"eks.amazonaws.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"eks\"\t\n\tconfig := clusterConfig.data\n    # logSetup is an object representing the enabled or disabled Kubernetes control plane logs for your cluster.\n    # types - available cluster control plane log types\n    # https://docs.aws.amazon.com/eks/latest/APIReference/API_LogSetup.html\n    goodTypes := [logSetup  | logSetup =  config.Cluster.Logging.ClusterLogging[_];  isAuditLogs(logSetup)]\n    count(goodTypes) == 0\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"audit logs is disabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n\nisLoggingDisabled(clusterConfig) {\n\tnot clusterConfig.logging_config.component_config.enable_components\n}\nisLoggingDisabled(clusterConfig) {\n\tclusterConfig.logging_config.component_config.enable_components\n\tcount(clusterConfig.logging_config.component_config.enable_components) == 0\n}\n\nisAuditLogs(logSetup) {\n    logSetup.Enabled == true\n    cautils.list_contains(logSetup.Types, \"api\")\n}\n\nisAuditLogs(logSetup) {\n    logSetup.Enabled == true\n    cautils.list_contains(logSetup.Types, \"audit\")\n}\n\nisAuditLogs(logSetup) {\n    logSetup.enabled == true\n    cautils.list_contains(logSetup.Types, \"authenticator\")\n}"
                },
                {
                    "name": "k8s-audit-logs-enabled-native",
                    "attributes": {
                        "armoBuiltin": true,
                        "resourcesAggregator": "apiserver-pod",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Pod"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Check if audit logs is  enabled for native k8s\ndeny[msga] {\n\tapiserverpod := input[_]\n    cmd := apiserverpod.spec.containers[0].command\n\tauditPolicy :=  [ command |command := cmd[_] ; contains(command, \"--audit-policy-file=\")]\n    count(auditPolicy) < 1\n\tpath := \"spec.containers[0].command\"\t\n\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"audit logs is not enabled\",\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [apiserverpod],\n\t\t\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Secret/ETCD encryption enabled",
            "attributes": {
                "armoBuiltin": true
            },
            "description": "All Kubernetes Secrets are stored primarily in etcd therefore it is important to encrypt it.",
            "remediation": "Turn on the etcd encryption in your cluster, for more see the vendor documentation.",
            "id": "C-0066",
            "long_description": "etcd is a consistent and highly-available key value store used as Kubernetes' backing store for all cluster data. All object data in Kubernetes, like secrets, are stored there. This is the reason why it is important to protect the contents of etcd and use its data encryption feature.",
            "test": "Reading the cluster descritpion from the managed cloud API (EKS, GKE), or the API server pod configuration for native K8s and checking if etcd encryption is enabled",
            "controlID": "C-0066",
            "baseScore": 3,
            "rules": [
                {
                    "name": "secret-etcd-encryption-cloud",
                    "attributes": {
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [],
                            "apiVersions": [],
                            "resources": []
                        }
                    ],
                    "dynamicMatch": [
                        {
                            "apiGroups": [
                                "container.googleapis.com",
                                "eks.amazonaws.com"
                            ],
                            "apiVersions": [
                                "v1"
                            ],
                            "resources": [
                                "ClusterDescribe"
                            ]
                        }
                    ],
                    "relevantCloudProviders": [
                        "EKS",
                        "GKE"
                    ],
                    "ruleDependencies": [],
                    "description": "",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n\n# Check if encryption in etcd in enabled for EKS\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"eks.amazonaws.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"eks\"\t\n\tconfig = clusterConfig.data\n\n\tisNotEncryptedEKS(config)\n    \n\t\n\tmsga := {\n\t\t\"alertMessage\": \"etcd/secret encryption is not enabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\":[] ,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n\n\n# Check if encryption in etcd in enabled for GKE\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"container.googleapis.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"gke\"\t\n\tconfig := clusterConfig.data\n\n\tnot isEncryptedGKE(config)\n    \n\t\n\tmsga := {\n\t\t\"alertMessage\": \"etcd/secret encryption is not enabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\nisEncryptedGKE(config) {\n\t config.database_encryption.state == \"1\"\n}\nisEncryptedGKE(config) {\n\t config.database_encryption.state == \"ENCRYPTED\"\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tencryptionConfig := clusterConfig.Cluster.EncryptionConfig[_]\n    goodResources := [resource  | resource =   clusterConfig.Cluster.EncryptionConfig.Resources[_]; resource == \"secrets\"]\n\tcount(goodResources) == 0\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tclusterConfig.Cluster.EncryptionConfig == null\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tcount(clusterConfig.Cluster.EncryptionConfig) == 0\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tencryptionConfig := clusterConfig.Cluster.EncryptionConfig[_]\n    count(encryptionConfig.Resources) == 0\n}"
                },
                {
                    "name": "etcd-encryption-native",
                    "attributes": {
                        "armoBuiltin": true,
                        "resourcesAggregator": "apiserver-pod",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Pod"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Check if encryption in etcd is enabled for native k8s\ndeny[msga] {\n\tapiserverpod := input[_]\n    cmd := apiserverpod.spec.containers[0].command\n    encCommand :=  [ command |command := cmd[_] ; contains(command, \"--encryption-provider-config=\")]\n    count(encCommand) < 1\n\tpath := \"spec.containers[0].command\"\t\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"etcd encryption is not enabled\",\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [apiserverpod],\n\t\t\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "PSP enabled",
            "attributes": {
                "armoBuiltin": true
            },
            "description": "PSP enable fine-grained authorization of pod creation and it is important to enable it",
            "remediation": "Turn Pod Security Policies on in your cluster, if you use other admission controllers to control the behavior that PSP controls, exclude this control from your scans",
            "id": "C-0068",
            "long_description": "Pod Security Policies enable fine-grained authorization of pod creation and updates and it extends authorization  beyond RBAC. It is an important to use PSP to control the creation of sensitive PODs in your cluster.",
            "test": "Reading the cluster descritpion from the managed cloud API (EKS, GKE), or the API server pod configuration for native K8s and checking if PSP is enabled",
            "controlID": "C-0068",
            "baseScore": 3,
            "rules": [
                {
                    "name": "psp-enabled-cloud",
                    "attributes": {
                        "armoBuiltin": true
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [],
                            "apiVersions": [],
                            "resources": []
                        }
                    ],
                    "dynamicMatch": [
                        {
                            "apiGroups": [
                                "container.googleapis.com",
                                "eks.amazonaws.com"
                            ],
                            "apiVersions": [
                                "v1"
                            ],
                            "resources": [
                                "ClusterDescribe"
                            ]
                        }
                    ],
                    "relevantCloudProviders": [
                        "EKS",
                        "GKE"
                    ],
                    "ruleDependencies": [],
                    "description": "",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n\n# Check if PSP is enabled for GKE\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"container.googleapis.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"gke\"\t\n\tconfig := clusterConfig.data\n    not config.pod_security_policy_config.enabled == true\n\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"pod security policy configuration is not enabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n# TODO - EKS. By default has a policy which allows everything"
                },
                {
                    "name": "psp-enabled-native",
                    "attributes": {
                        "armoBuiltin": true,
                        "resourcesAggregator": "apiserver-pod",
                        "useFromKubescapeVersion": "v1.0.133"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [
                                "*"
                            ],
                            "apiVersions": [
                                "*"
                            ],
                            "resources": [
                                "Pod"
                            ]
                        }
                    ],
                    "ruleDependencies": [],
                    "description": "",
                    "remediation": "",
                    "ruleQuery": "armo_builtins",
                    "rule": "package armo_builtins\n\n\n# Check if psp is enabled for native k8s\ndeny[msga] {\n\tapiserverpod := input[_]\n    cmd := apiserverpod.spec.containers[0].command[j]\n    contains(cmd, \"--enable-admission-plugins=\")\n    output := split(cmd, \"=\")\n    not contains(output[1], \"PodSecurityPolicy\")\n\tpath := sprintf(\"spec.containers[0].command[%v]\", [format_int(j, 10)])\t\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"PodSecurityPolicy is not enabled\",\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [apiserverpod],\n\t\t\n\t\t}\n\t}\n}"
                }
            ]
        },
        {
            "name": "Disable anonymous access to Kubelet service",
            "attributes": {
                "armoBuiltin": true
            },
            "description": "By default, requests to the kubelet's HTTPS endpoint that are not rejected by other configured authentication methods are treated as anonymous requests, and given a username of system:anonymous and a group of system:unauthenticated.",
            "remediation": "Start the kubelet with the --anonymous-auth=false flag.",
            "id": "C-0069",
            "long_description": "By default, requests to the kubelet's HTTPS endpoint that are not rejected by other configured authentication methods are treated as anonymous requests, and given a username of system:anonymous and a group of system:unauthenticated.",
            "test": "Reading the kubelet command lines and configuration file looking for anonymous-auth configuration. If this configuration is set on both, the command line values take precedence over it.",
            "controlID": "C-0069",
            "baseScore": 10,
            "rules": [
                {
                    "name": "anonymous-requests-to-kubelet-service",
                    "attributes": {
                        "armoBuiltin": true,
                        "hostSensorRule": "true"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [],
                            "apiVersions": [],
                            "resources": []
                        }
                    ],
                    "dynamicMatch": [
                        {
                            "apiGroups": [
                                "hostdata.kubescape.cloud"
                            ],
                            "apiVersions": [
                                "v1beta0"
                            ],
                            "resources": [
                                "KubeletConfiguration",
                                "KubeletCommandLine"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        },
                        {
                            "packageName": "kubernetes.api.client"
                        }
                    ],
                    "description": "Determines if anonymous requests are to kubelet service are allowed.",
                    "remediation": "Disable anonymous requests by setting  the anonymous-auth flag to false, or using the kubelet configuration file.",
                    "ruleQuery": "",
                    "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\t\t\n\n\t\texternalObj := isAnonymouRequestsDisabled(kubeletConfig, kubeletCli)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"anonymous requests is enabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"failedPaths\": [],\n\t\t\t\"fixPaths\":[],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"externalObjects\": externalObj\n\t\t\t}\n\t\t}\n\t}\n\n# CLI overrides config\nisAnonymouRequestsDisabled(kubeletConfig, kubeletCli) = obj {\n\tkubeletCliData := kubeletCli.data\n\tcontains(kubeletCliData[\"fullCommand\"], \"anonymous-auth=true\")\n    obj := kubeletCli\n}\n\nisAnonymouRequestsDisabled(kubeletConfig, kubeletCli) = obj {\n\tkubeletConfig.data.authentication.anonymous.enabled == true\n\tkubeletCliData := kubeletCli.data\n\tnot contains(kubeletCliData[\"fullCommand\"], \"anonymous-auth=false\")\n    not contains(kubeletCliData[\"fullCommand\"], \"anonymous-auth=true\")\n    obj := kubeletConfig\n}",
                    "resourceEnumerator": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\texternalObj := getObj(kubeletConfig, kubeletCli)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"anonymous requests is enabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"failedPaths\": [],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"externalObjects\": externalObj\n\t\t\t}\n\t\t}\n\t}\n\ngetObj(kubeletConfig, kubeletCli) = obj {\n\tkubeletCli.data[\"anonymous-auth\"] == false\n    obj := kubeletCli\n}\n\ngetObj(kubeletConfig, kubeletCli) = obj {\n\tkubeletCli.data[\"anonymous-auth\"] == true\n    obj := kubeletCli\n}\n\ngetObj(kubeletConfig, kubeletCli) = obj {\n\tnot kubeletCli.data[\"anonymous-auth\"] == true\n    not kubeletCli.data[\"anonymous-auth\"] == false\n    obj := kubeletConfig\n}"
                }
            ]
        },
        {
            "name": "Enforce Kubelet client TLS authentication",
            "attributes": {
                "armoBuiltin": true
            },
            "description": "Kubelets are the node level orchestrator in Kubernetes control plane. They are publishing service port 10250 where they accept commands from API server. Operator must make sure that only API server is allowed to submit commands to Kubelet. This is done through client certificate verification, must configure Kubelet with client CA file to use for this purpose.",
            "remediation": "Start the kubelet with the --client-ca-file flag, providing a CA bundle to verify client certificates with.",
            "id": "C-0070",
            "long_description": "Kubelets are the node level orchestrator in Kubernetes control plane. They are publishing service port 10250 where they accept commands from API server. Operator must make sure that only API server is allowed to submit commands to Kubelet. This is done through client certificate verification, must configure Kubelet with client CA file to use for this purpose.",
            "test": "Reading the kubelet command lines and configuration file looking for client TLS configuration.",
            "controlID": "C-0070",
            "baseScore": 10,
            "rules": [
                {
                    "name": "enforce-kubelet-client-tls-authentication",
                    "attributes": {
                        "armoBuiltin": true,
                        "hostSensorRule": "true"
                    },
                    "ruleLanguage": "Rego",
                    "match": [
                        {
                            "apiGroups": [],
                            "apiVersions": [],
                            "resources": []
                        }
                    ],
                    "dynamicMatch": [
                        {
                            "apiGroups": [
                                "hostdata.kubescape.cloud"
                            ],
                            "apiVersions": [
                                "v1beta0"
                            ],
                            "resources": [
                                "KubeletConfiguration",
                                "KubeletCommandLine"
                            ]
                        }
                    ],
                    "ruleDependencies": [
                        {
                            "packageName": "cautils"
                        },
                        {
                            "packageName": "kubernetes.api.client"
                        }
                    ],
                    "description": "Determines if kubelet client tls authentication is enabled.",
                    "remediation": "Start the kubelet with the --client-ca-file flag, providing a CA bundle to verify client certificates with.",
                    "ruleQuery": "",
                    "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\t\tkubeletCliData := kubeletCli.data\n\n\n\t\tisClientTlsDisabled(kubeletConfig, kubeletCliData)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"kubelet client TLS authentication is not enabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"failedPaths\": [],\n\t\t\t\"fixPaths\":[],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [kubeletConfig, kubeletCli]\n\t\t\t},\n\t\t}\n\t}\n\n# CLI overrides config\nisClientTlsDisabled(kubeletConfig, kubeletCliData) {\n\tnot contains(kubeletCliData[\"fullCommand\"], \"client-ca-file\")\n    not kubeletConfig.data.authentication.x509.clientCAFile\n}\n"
                }
            ]
        }
    ]
}