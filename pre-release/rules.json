[
    {
        "name": "rule-credentials-in-env-var",
        "attributes": {
            "m$K8sThreatMatrix": "Credential access::Applications credentials in configuration files, Lateral Movement::Applications credentials in configuration files",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "configInputs": [
            "settings.postureControlInputs.sensitiveKeyNames"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.sensitiveKeyNames",
                "name": "Keys",
                "description": "Secrets are stored as a key/value pair. The names of the keys/values may change from one company to the other. Here you can find some examples of popular key phrases that Kubescape is searching for"
            }
        ],
        "description": "fails if Pods have sensitive information in configuration",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "\tpackage armo_builtins\n\t# import data.cautils as cautils\n\t# import data.kubernetes.api.client as client\n\timport data\n\n\tdeny[msga] {\n\t\tpod := input[_]\n\t\tpod.kind == \"Pod\"\n\t\t# see default-config-inputs.json for list values\n\t\tsensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n\t\tkey_name := sensitive_key_names[_]\n\t\tcontainer := pod.spec.containers[i]\n\t\tenv := container.env[j]\n\t\tcontains(lower(env.name), key_name)\n\t\tisNotReference(env)\n\t\tpath := sprintf(\"spec.containers[%v].env[%v].name\", [format_int(i, 10), format_int(j, 10)])\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"Pod: %v has sensitive information in environment variables\", [pod.metadata.name]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [pod]\n\t\t\t}\n\t\t}\n\t}\n\n\tdeny[msga] {\n\t\twl := input[_]\n\t\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\t\tspec_template_spec_patterns[wl.kind]\n\n\t\t# see default-config-inputs.json for list values\n\t\tsensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n\t\tkey_name := sensitive_key_names[_]\n\t\tcontainer := wl.spec.template.spec.containers[i]\n\t\tenv := container.env[j]\n\t\tcontains(lower(env.name), key_name)\n\t\tisNotReference(env)\n\t\tpath := sprintf(\"spec.template.spec.containers[%v].env[%v].name\", [format_int(i, 10), format_int(j, 10)])\t\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"%v: %v has sensitive information in environment variables\", [wl.kind, wl.metadata.name]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [wl]\n\t\t\t}\n\t\t}\n\t}\n\n\tdeny[msga] {\n\t\twl := input[_]\n\t\twl.kind == \"CronJob\"\n\t\t# see default-config-inputs.json for list values\n\t\tsensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n\t\tkey_name := sensitive_key_names[_]\n\t\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\t\tenv := container.env[j]\n\t\tcontains(lower(env.name), key_name)\n\t\tisNotReference(env)\n\t\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].env[%v].name\", [format_int(i, 10), format_int(j, 10)])\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"Cronjob: %v has sensitive information in environment variables\", [wl.metadata.name]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [wl]\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tisNotReference(env)\n\t{\n\t\tnot env.valueFrom.secretKeyRef\n\t\tnot env.valueFrom.configMapKeyRef\n\t}\n\n"
    },
    {
        "name": "rule-allow-privilege-escalation",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob",
                    "PodSecurityPolicy"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if container allows privilege escalation",
        "remediation": "Make sure that the allowPrivilegeEscalation field in the securityContext of pod/container is set to false",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if pod has container  that allow privilege escalation\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n    result := isAllowPrivilegeEscalationContainer(container, i, begginingOfPath)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  allow privilege escalation\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n\n# Fails if workload has a container that allow privilege escalation\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result := isAllowPrivilegeEscalationContainer(container, i, begginingOfPath)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v  allow privilege escalation\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n# Fails if cronjob has a container that allow privilege escalation\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tresult := isAllowPrivilegeEscalationContainer(container, i, begginingOfPath)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v allow privilege escalation\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\nisAllowPrivilegeEscalationContainer(container, i, begginingOfPath) = [failedPath, fixPath] {\n    not container.securityContext.allowPrivilegeEscalation == false\n\tnot container.securityContext.allowPrivilegeEscalation == true\n\tpsps := [psp |  psp= input[_]; psp.kind == \"PodSecurityPolicy\"]\n\tcount(psps) == 0\n\tfailedPath = \"\"\n\tfixPath = {\"path\": sprintf(\"%vcontainers[%v].securityContext.allowPrivilegeEscalation\", [begginingOfPath, format_int(i, 10)]), \"value\":\"false\"} \n}\n\nisAllowPrivilegeEscalationContainer(container, i, begginingOfPath) = [failedPath, fixPath] {\n    not container.securityContext.allowPrivilegeEscalation == false\n\tnot container.securityContext.allowPrivilegeEscalation == true\n\tpsps := [psp |  psp= input[_]; psp.kind == \"PodSecurityPolicy\"]\n\tcount(psps) > 0\n\tpsp := psps[_]\n\tnot psp.spec.allowPrivilegeEscalation == false\n\tfailedPath = \"\"\n\tfixPath = {\"path\": sprintf(\"%vcontainers[%v].securityContext.allowPrivilegeEscalation\", [begginingOfPath, format_int(i, 10)]), \"value\":\"false\"} \n}\n\n\nisAllowPrivilegeEscalationContainer(container, i, begginingOfPath) = [failedPath, fixPath]  {\n    container.securityContext.allowPrivilegeEscalation == true\n\tpsps := [psp |  psp= input[_]; psp.kind == \"PodSecurityPolicy\"]\n\tcount(psps) == 0\n\tfixPath = \"\"\n\tfailedPath = sprintf(\"%vcontainers[%v].securityContext.allowPrivilegeEscalation\", [begginingOfPath, format_int(i, 10)])\n}\n\nisAllowPrivilegeEscalationContainer(container, i, begginingOfPath)= [failedPath, fixPath] {\n    container.securityContext.allowPrivilegeEscalation == true\n\tpsps := [psp |  psp= input[_]; psp.kind == \"PodSecurityPolicy\"]\n\tcount(psps) > 0\n\tpsp := psps[_]\n\tnot psp.spec.allowPrivilegeEscalation == false\n\tfixPath = \"\"\n\tfailedPath = sprintf(\"%vcontainers[%v].securityContext.allowPrivilegeEscalation\", [begginingOfPath, format_int(i, 10)])\n}\n\n getFailedPath(paths) = [paths[0]] {\n\tpaths[0] != \"\"\n} else = []\n\n\ngetFixedPath(paths) = [paths[1]] {\n\tpaths[1] != \"\"\n} else = []\n\n"
    },
    {
        "name": "resource-policies",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if namespace has no resource policies defined",
        "remediation": "Make sure that you definy resource policies (LimitRange or ResourceQuota) which limit the usage of resources for all the namespaces",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Check if container has limits\ndeny[msga] {\n  \tpods := [pod | pod = input[_]; pod.kind == \"Pod\"]\n    pod := pods[_]\n\tcontainer := pod.spec.containers[i]\n\t\n\t\n\tbegginingOfPath := \"spec.\"\n\tfixPath := isNoCpuAndMemoryLimitsDefined(container, begginingOfPath, i)\n\t\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"there are no cpu and memory  limits defined for container : %v\",  [container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixPath,\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n\n# Check if container has limits - for workloads\n# If there is no limits specified in the workload, we check the namespace, since if limits are only specified for namespace\n# and not in workload, it won't be on the yaml\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\t\n\tbegginingOfPath\t:= \"spec.template.spec.\"\n\tfixPath := isNoCpuAndMemoryLimitsDefined(container, begginingOfPath, i)\n\t\n\t\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"there are no cpu and memory limits defined for container : %v\",  [container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixPath,\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n\t\n}\n\n# Check if container has limits - for cronjobs\n# If there is no limits specified in the cronjob, we check the namespace, since if limits are only specified for namespace\n# and not in cronjob, it won't be on the yaml\ndeny [msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\t\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tfixPath := isNoCpuAndMemoryLimitsDefined(container, begginingOfPath, i)\n\t\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"there are no cpu and memory limits defined for container : %v\",  [container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixPath,\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# no limits at all\nisNoCpuAndMemoryLimitsDefined(container, begginingOfPath, i) =  fixPath {\n\tnot container.resources.limits\n\tfixPath = [{\"path\": sprintf(\"%vcontainers[%v].resources.limits.cpu\", [begginingOfPath, format_int(i, 10)]), \"value\":\"YOUR_VALUE\"}, {\"path\": sprintf(\"%vcontainers[%v].resources.limits.memory\", [begginingOfPath, format_int(i, 10)]), \"value\":\"YOUR_VALUE\"}]\n}\n\n# only memory limit\nisNoCpuAndMemoryLimitsDefined(container, begginingOfPath, i) = fixPath {\n\tcontainer.resources.limits\n\tnot container.resources.limits.cpu\n\tcontainer.resources.limits.memory\n\tfixPath = [{\"path\": sprintf(\"%vcontainers[%v].resources.limits.cpu\", [begginingOfPath, format_int(i, 10)]), \"value\":\"YOUR_VALUE\"}]\n}\n\n# only cpu limit\nisNoCpuAndMemoryLimitsDefined(container, begginingOfPath, i) =fixPath {\n\tcontainer.resources.limits\n\tnot container.resources.limits.memory\n\tcontainer.resources.limits.cpu\n\tfixPath = [{\"path\": sprintf(\"%vcontainers[%v].resources.limits.memory\", [begginingOfPath, format_int(i, 10)]), \"value\":\"YOUR_VALUE\"}]\n\tfailedPath = \"\"\n}\n# limits but without capu and memory \nisNoCpuAndMemoryLimitsDefined(container, begginingOfPath, i) = fixPath {\n\tcontainer.resources.limits\n\tnot container.resources.limits.memory\n\tnot container.resources.limits.cpu\n\tfixPath = [{\"path\": sprintf(\"%vcontainers[%v].resources.limits.cpu\", [begginingOfPath, format_int(i, 10)]), \"value\":\"YOUR_VALUE\"}, {\"path\": sprintf(\"%vcontainers[%v].resources.limits.memory\", [begginingOfPath, format_int(i, 10)]), \"value\":\"YOUR_VALUE\"}]\n}"
    },
    {
        "name": "rule-access-dashboard-wl-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Lateral Movement::Access Kubernetes dashboard, Discovery::Access Kubernetes dashboard",
            "armoBuiltin": true,
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if subject that is not dashboard service account is bound to dashboard role/clusterrole, or- if anyone that is not dashboard pod is associated with its service account.",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: \n# apiversion: \n# fails if pod that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    pod := input[_]\n    pod.spec.serviceAccountName == \"kubernetes-dashboard\"\n    not startswith(pod.metadata.name, \"kubernetes-dashboard\")\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following pods: %s are associated with dashboard service account\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [\"spec.serviceaccountname\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if workload that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    wl.spec.template.spec.serviceAccountName == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is associated with dashboard service account\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [\"spec.template.spec.serviceaccountname\"],\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if CronJob that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    wl.spec.jobTemplate.spec.template.spec.serviceAccountName == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjob: %s is associated with dashboard service account\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [\"spec.jobTemplate.spec.template.spec.serviceaccountname\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}"
    },
    {
        "name": "deny-vuln-image-pods",
        "attributes": {
            "m$K8sThreatMatrix": "Initial Access::Application Vulnerability",
            "mitre": "Exploit Public-Facing Application",
            "mitreCode": "T1190",
            "armoBuiltin": true,
            "armoOpa": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod",
                    "services"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines if pods/deployments has vulnerable image",
        "remediation": "Isolate such deployments in sandboxes if possible. Otherwise, keep scanning frequently for in case a patch will be available - MAKE SURE it has least privileges as necessary!",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n    \ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == pod.metadata.namespace\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,filtered_labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"pod %v/%v has vulnerabilities\", [pod.metadata.namespace,pod.metadata.name]),\n        \"alertScore\": 2,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t},\n\t\t\"externalObjects\": {\n\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t}\n    }\n}\n\n# covers most workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\n\tlabels := wl.spec.template.metadata.labels\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"%v: %v/%v has vulnerabilities\", [wl.kind, wl.metadata.namespace, wl.metadata.name]),\n        \"alertScore\": 2,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t},\n\t\t\"externalObjects\": {\n\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t}\n    }\n}\n\n# covers cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\t\n\n    msga := {\n        \"alertMessage\": sprintf(\"%v: %v/%v has vulnerabilities\", [wl.kind, wl.metadata.namespace, wl.metadata.name]),\n        \"alertScore\": 2,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t},\n\t\t\"externalObjects\": {\n\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t}\n    }\n}\n\n\n#treat as potentially critical\nis_unsafe_image(scanresult) {\n\tscanresult.numOfUnknownSeverity > 0\n}\nis_unsafe_image(scanresult) {\n\tscanresult.numOfNegligibleSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfLowSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfMeduiumSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfHighSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfCriticalSeverity > 0\n}\n"
    },
    {
        "name": "rule-identify-blocklisted-image-registries",
        "attributes": {
            "m$K8sThreatMatrix": "Initial Access::Compromised images in registry",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pods",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "configInputs": [
            "settings.postureControlInputs.publicRegistries",
            "settings.postureControlInputs.untrustedRegistries"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.publicRegistries",
                "name": "Public registries",
                "description": "Kubescape checks none of these public registries are in use."
            },
            {
                "path": "settings.postureControlInputs.untrustedRegistries",
                "name": "Registries block list",
                "description": "Kubescape checks none of the following registries are in use."
            }
        ],
        "description": "Identifying if pod container images are from unallowed registries",
        "remediation": "Use images from safe registry",
        "ruleQuery": "",
        "rule": "package armo_builtins\nimport data\n# Check for images from blocklisted repos\n\nuntrustedImageRepo[msga] {\n\tpod := input[_]\n\tk := pod.kind\n\tk == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n\timage := container.image\n    untrusted_or_public_registries(image)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"image '%v' in container '%s' comes from untrusted registry\", [image, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n    }\n}\n\nuntrustedImageRepo[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\timage := container.image\n    untrusted_or_public_registries(image)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"image '%v' in container '%s' comes from untrusted registry\", [image, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n    }\n}\n\nuntrustedImageRepo[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\timage := container.image\n    untrusted_or_public_registries(image)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"image '%v' in container '%s' comes from untrusted registry\", [image, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n    }\n}\n\nuntrusted_or_public_registries(image){\n\t# see default-config-inputs.json for list values\n\tuntrusted_registries := data.postureControlInputs.untrustedRegistries\n\trepo_prefix := untrusted_registries[_]\n\tstartswith(image, repo_prefix)\n}\n\nuntrusted_or_public_registries(image){\n\t# see default-config-inputs.json for list values\n\tpublic_registries := data.postureControlInputs.publicRegistries\n\trepo_prefix := public_registries[_]\n\tstartswith(image, repo_prefix)\n}\n\nuntrusted_or_public_registries(image){\n\t# the lack of registry name defaults to docker hub\n\tnot contains(image, \"/\")\n}"
    },
    {
        "name": "secret-etcd-encryption-cloud",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [],
                "apiVersions": [],
                "resources": []
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "container.googleapis.com",
                    "eks.amazonaws.com"
                ],
                "apiVersions": [
                    "v1"
                ],
                "resources": [
                    "ClusterDescribe"
                ]
            }
        ],
        "relevantCloudProviders": [
            "EKS",
            "GKE"
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Check if encryption in etcd in enabled for EKS\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"eks.amazonaws.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"eks\"\t\n\tconfig = clusterConfig.data\n\n\tisNotEncryptedEKS(config)\n    \n\t\n\tmsga := {\n\t\t\"alertMessage\": \"etcd/secret encryption is not enabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\":[] ,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n\n\n# Check if encryption in etcd in enabled for GKE\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"container.googleapis.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"gke\"\t\n\tconfig := clusterConfig.data\n\n\tnot isEncryptedGKE(config)\n    \n\t\n\tmsga := {\n\t\t\"alertMessage\": \"etcd/secret encryption is not enabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\nisEncryptedGKE(config) {\n\t config.database_encryption.state == \"1\"\n}\nisEncryptedGKE(config) {\n\t config.database_encryption.state == \"ENCRYPTED\"\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tencryptionConfig := clusterConfig.Cluster.EncryptionConfig[_]\n    goodResources := [resource  | resource =   clusterConfig.Cluster.EncryptionConfig.Resources[_]; resource == \"secrets\"]\n\tcount(goodResources) == 0\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tclusterConfig.Cluster.EncryptionConfig == null\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tcount(clusterConfig.Cluster.EncryptionConfig) == 0\n}\n\nisNotEncryptedEKS(clusterConfig) {\n\tencryptionConfig := clusterConfig.Cluster.EncryptionConfig[_]\n    count(encryptionConfig.Resources) == 0\n}"
    },
    {
        "name": "rule-credentials-configmap",
        "attributes": {
            "m$K8sThreatMatrix": "Credential access::Applications credentials in configuration files, Lateral Movement::Applications credentials in configuration files",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "ConfigMap"
                ]
            }
        ],
        "ruleDependencies": [],
        "configInputs": [
            "settings.postureControlInputs.sensitiveValues",
            "settings.postureControlInputs.sensitiveKeyNames"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.sensitiveValues",
                "name": "Values",
                "description": "Secrets are stored as a key/value pair. The names of the keys/values may change from one company to the other. Below you can find some examples of popular value phrases that Kubescape is searching for"
            },
            {
                "path": "settings.postureControlInputs.sensitiveKeyNames",
                "name": "Keys",
                "description": "Secrets are stored as a key/value pair. The names of the keys/values may change from one company to the other. Here you can find some examples of popular key phrases that Kubescape is searching for"
            }
        ],
        "description": "fails if ConfigMaps have sensitive information in configuration",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n# import data.cautils as cautils\n# import data.kubernetes.api.client as client\nimport data\n\n# fails if config map has keys with suspicious name\ndeny[msga] {\n\tconfigmap := input[_]\n    configmap.kind == \"ConfigMap\"\n    # see default-config-inputs.json for list values\n    sensitive_key_names := data.postureControlInputs.sensitiveKeyNames\n    key_name := sensitive_key_names[_]\n    map_secret := configmap.data[map_key]\n    contains(lower(map_key), lower(key_name))\n    path := sprintf(\"data[%v]\", [map_key])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"this configmap has sensitive information: %v\", [configmap.metadata.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n        \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [configmap]\n\t\t}\n     }\n}\n\n# fails if config map has values with suspicious content - not base 64\ndeny[msga] {\n    # see default-config-inputs.json for list values\n    sensitive_values := data.postureControlInputs.sensitiveValues\n    value := sensitive_values[_]\n\n\tconfigmap := input[_]\n    configmap.kind == \"ConfigMap\"\n    map_secret := configmap.data[map_key]\n    regex.match(value , map_secret)\n    path := sprintf(\"data[%v]\", [map_key])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"this configmap has sensitive information: %v\", [configmap.metadata.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n        \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [configmap]\n\t\t}\n     }\n}\n\n# fails if config map has values with suspicious content - base 64\ndeny[msga] {\n    # see default-config-inputs.json for list values\n    sensitive_values := data.postureControlInputs.sensitiveValues\n    value := sensitive_values[_]\n\n\tconfigmap := input[_]\n    configmap.kind == \"ConfigMap\"\n    map_secret := configmap.data[map_key]\n    decoded_secret := base64.decode(map_secret)\n    regex.match(value , decoded_secret)\n    path := sprintf(\"data[%v]\", [map_key])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"this configmap has sensitive information: %v\", [configmap.metadata.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n        \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [configmap]\n\t\t}\n     }\n}"
    },
    {
        "name": "configured-readiness-probe",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Readiness probe is not configured",
        "remediation": "Ensure Readiness probe is configured",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if pod doas not have container with readinessProbe\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    container := pod.spec.containers[i]\n\tnot container.readinessProbe\n\tfixPath := {\"path\": sprintf(\"spec.containers[%v].readinessProbe\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v does not have readinessProbe\", [ container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [fixPath],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if workload doas not have container with readinessProbe\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n    not container.readinessProbe\n\tfixPath := {\"path\": sprintf(\"spec.template.spec.containers[%v].readinessProbe\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have readinessProbe\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [fixPath],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if cronjob doas not have container with readinessProbe\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n    not container.readinessProbe\n\tfixPath := {\"path\": sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].readinessProbe\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have readinessProbe\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [fixPath],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n"
    },
    {
        "name": "rule-can-bash-cmd-inside-container",
        "attributes": {
            "microsoftK8sThreatMatrix": "Execution::Bash/cmd inside container",
            "armoBuiltin": true,
            "armoOpa": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.listOfDangerousArtifcats",
                "name": "Shell executable in container",
                "description": "Kubescape checks if container images have the any of the these shell executables."
            }
        ],
        "description": "determines which containers have bash/cmd inside it",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\nimport data\n\n\n# Fails if container has bash/cmd inside it \n# Pods\ndeny [msga] {\n    pod := input[_]\n    container := pod.spec.containers[i]\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    isBashContainer(scan)\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n    \n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following container: %v has bash/cmd inside it.\", [container.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"container\" : [{container.name}]\n\t\t\t}\n\t\t},\n\t}\n}\n\n\n# Workloads\ndeny [msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    isBashContainer(scan)\n\n    \n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following container: %v has bash/cmd inside it.\", [container.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"container\" : [{container.name}]\n\t\t\t}\n\t\t},\n\t}\n}\n\n# Cronjobs\ndeny [msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    isBashContainer(scan)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following container: %v has bash/cmd inside it.\", [container.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"container\" : [{container.name}]\n\t\t\t}\n\t\t},\n\t}\n}\n\n\nisBashContainer(scan) {\n\t# see default-config-inputs.json for list values\n\tshells :=  data.postureControlInputs.listOfDangerousArtifcats\n\tshell := shells[_]\n\tcautils.list_contains(scan.listOfDangerousArtifcats, shell)\n}\n"
    },
    {
        "name": "rule-can-delete-k8s-events",
        "attributes": {
            "microsoftK8sThreatMatrix": "Defense Evasion::Delete K8S events",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can delete events",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can delete events\n#RoleBinding to Role\ndeny [msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteEventsResource(rule)\n    canDeleteEventsVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete events\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can delete events\n#RoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteEventsResource(rule)\n    canDeleteEventsVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete events\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can delete events\n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteEventsResource(rule)\n    canDeleteEventsVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete events\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\ncanDeleteEventsResource(rule) {\n cautils.list_contains(rule.resources,\"events\")\n}\ncanDeleteEventsResource(rule) {\n isApiGroup(rule)\n cautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\ncanDeleteEventsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"delete\")\n}\n\ncanDeleteEventsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"deletecollection\")\n}\n\ncanDeleteEventsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"*\")\n}"
    },
    {
        "name": "naked-pods",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "v1"
                ],
                "resources": [
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Don't use naked Pods (that is, Pods not bound to a ReplicaSet or Deployment) if you can avoid it. Naked Pods will not be rescheduled in the event of a node failure.",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if workload is Pod\ndeny[msga] {\n    pod := input[_]\n\tpod.kind == \"Pod\"\n\tnot pod.metadata.ownerReferences\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v not associated with ReplicaSet or Deployment\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [{\"path\": \"metadata.ownerReferences\", \"value\": \"YOUR_VALUE\"}],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n\n"
    },
    {
        "name": "rule-can-create-bind-escalate-role",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can create/update rolebindings/clusterrolebindings or bind roles/clusterroles",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n# ================= create/update ===============================\n\n# fails if user has access to create/update rolebindings/clusterrolebindings\n# RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateUpdateToRoleResource(rule)\n    canCreateUpdateToRoleVerb(rule)\n  \n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can create/update rolebinding/clusterrolebinding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# fails if user has access to create/update rolebindings/clusterrolebindings\n# RoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateUpdateToRoleResource(rule)\n    canCreateUpdateToRoleVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n  \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can create/update rolebinding/clusterrolebinding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# fails if user has access to create/update rolebindings/clusterrolebindings\n# ClusterRoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n     clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n     clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateUpdateToRoleResource(rule)\n    canCreateUpdateToRoleVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n  \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can create/update rolebinding/clusterrolebinding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# ================= bind ===============================\n\n# fails if user has access to bind clusterroles/roles\n# RoleBinding to Role\ndeny [msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\n    canBindToRoleResource(rule)\n    canBindToRoleVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can bind roles/clusterroles\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n# fails if user has access to bind clusterroles/roles\n# RoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    \n    canBindToRoleResource(rule)\n    canBindToRoleVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n  msga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can bind roles/clusterroles\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n# fails if user has access to bind clusterroles/roles\n# ClusterRoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n     clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n     clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n     canBindToRoleResource(rule)\n    canBindToRoleVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n    \t\n   msga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can bind roles/clusterroles\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n# ================= escalate ===============================\n\n\n# fails if user has access to escalate rolebindings/clusterrolebindings\n# RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canEscalateToRoleResource(rule)\n    canEscalateToRoleVerb(rule)\n  \n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can escalate rolebinding/clusterrolebinding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# fails if user has access to escalate rolebindings/clusterrolebindings\n# RoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canEscalateToRoleResource(rule)\n    canEscalateToRoleVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n  \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can escalate rolebinding/clusterrolebinding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# fails if user has access to escalate rolebindings/clusterrolebindings\n# ClusterRoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n     clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n     clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canEscalateToRoleResource(rule)\n    canEscalateToRoleVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n    \t\n  \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v, can escalate rolebinding/clusterrolebinding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n# ============== escalate =====================\n\ncanEscalateToRoleResource(rule){\n     cautils.list_contains(rule.resources,\"clusterroles\")\n}\n\ncanEscalateToRoleResource(rule){\n     cautils.list_contains(rule.resources,\"roles\")\n}\n\ncanEscalateToRoleResource(rule){\n     isApiGroup(rule)\n     cautils.list_contains(rule.resources,\"*\")\n}\n\ncanEscalateToRoleVerb(rule) {\n       cautils.list_contains(rule.verbs, \"escalate\")\n}\n\ncanEscalateToRoleVerb(rule) {\n       cautils.list_contains(rule.verbs, \"*\")\n}\n\n\n# ============== bind =====================\n\ncanBindToRoleResource(rule){\n     cautils.list_contains(rule.resources,\"clusterroles\")\n}\n\ncanBindToRoleResource(rule){\n     cautils.list_contains(rule.resources,\"roles\")\n}\n\ncanBindToRoleResource(rule){\n     isApiGroup(rule)\n     cautils.list_contains(rule.resources,\"*\")\n}\n\n\ncanBindToRoleVerb(rule) {\n       cautils.list_contains(rule.verbs, \"bind\")\n}\n\ncanBindToRoleVerb(rule) {\n       cautils.list_contains(rule.verbs, \"*\")\n}\n\n# ============== create/update =====================\n\ncanCreateUpdateToRoleResource(rule) {\n      cautils.list_contains(rule.resources,\"rolebindings\")\n}\n\ncanCreateUpdateToRoleResource(rule) {\n      cautils.list_contains(rule.resources,\"clusterrolebindings\")\n}\n\ncanCreateUpdateToRoleResource(rule) {\n     isApiGroup(rule)\n     cautils.list_contains(rule.resources,\"*\")\n}\n\n\ncanCreateUpdateToRoleVerb(rule) {\n     cautils.list_contains(rule.verbs, \"create\")\n}\n\ncanCreateUpdateToRoleVerb(rule) {\n     cautils.list_contains(rule.verbs, \"update\")\n}\n\ncanCreateUpdateToRoleVerb(rule) {\n     cautils.list_contains(rule.verbs, \"patch\")\n}\n\ncanCreateUpdateToRoleVerb(rule) {\n     cautils.list_contains(rule.verbs, \"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"rbac.authorization.k8s.io\"\n}"
    },
    {
        "name": "containers-mounting-docker-socket",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pod",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Check hostpath. If the path is set to /var/run/docker.sock or /var/lib/docker , the container has access to Docker internals - fail.",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    volume := pod.spec.volumes[i]\n\thostPath := volume.hostPath\n    isDockerMounting(hostPath)\n\tpath := sprintf(\"spec.volumes[%v].hostPath.path\", [format_int(i, 10)])\n    msga := {\n\t\t\"alertMessage\": sprintf(\"volume: %v in pod: %v has mounting to Docker internals.\", [volume.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"alertScore\": 5,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\t\n}\n\n\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    volume := wl.spec.template.spec.volumes[i]\n\thostPath := volume.hostPath\n    isDockerMounting(hostPath)\n\tpath := sprintf(\"spec.template.spec.volumes[%v].hostPath.path\", [format_int(i, 10)])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"volume: %v in %v: %v has mounting to Docker internals.\", [ volume.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"alertScore\": 5,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tvolume = wl.spec.jobTemplate.spec.template.spec.volumes[i]\n    hostPath := volume.hostPath\n    isDockerMounting(hostPath)\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.volumes[%v].hostPath.path\", [format_int(i, 10)])\n    msga := {\n\t\t\"alertMessage\": sprintf(\"volume: %v in %v: %v has mounting to Docker internals.\", [ volume.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"alertScore\": 5,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\nisDockerMounting(hostPath) {\n\thostPath.path == \"/var/run/docker.sock\"\n}\n\nisDockerMounting(hostPath) {\n\thostPath.path == \"/var/run/docker\"\n}\n"
    },
    {
        "name": "rule-can-delete-logs",
        "attributes": {
            "microsoftK8sThreatMatrix": "Defense Evasion::Clear container logs",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can delete logs inside a container",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n\n\n# fails if user can delete logs of pod \n#RoleBinding to Role\ndeny [msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteLogs(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n      \"alertMessage\": sprintf(\"The following %v: %v can delete logs\", [subject.kind, subject.name]),\n      \"alertScore\": 6,\n      \"failedPaths\": [path],\n      \"packagename\": \"armo_builtins\",\n      \"alertObject\": {\n        \"k8sApiObjects\": [role,rolebinding],\n\t\t\t    \"externalObjects\": {\n\t\t\t\t    \"subject\" : [subject]\n\t\t\t    }\n      }\n    }\n\n}\n\n\n# fails if user can delete logs of pod \n# RoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteLogs(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n      \"alertMessage\": sprintf(\"The following %v: %v can delete logs\", [subject.kind, subject.name]),\n      \"alertScore\": 6,\n      \"failedPaths\": [path],\n      \"packagename\": \"armo_builtins\",\n      \"alertObject\": {\n        \"k8sApiObjects\": [role,rolebinding],\n        \"externalObjects\": {\n          \"subject\" : [subject]\n        }\n      }\n    }\n}\n\n# fails if user can delete logs of pod \n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteLogs(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n      \"alertMessage\": sprintf(\"The following %v: %v can delete logs\", [subject.kind, subject.name]),\n      \"alertScore\": 6,\n      \"failedPaths\": [path],\n      \"packagename\": \"armo_builtins\",\n      \"alertObject\": {\n        \"k8sApiObjects\": [role,clusterrolebinding],\n        \"externalObjects\": {\n          \"subject\" : [subject]\n        }\n      }\n    }\n}\n\n\n\n\ncanDeleteLogs(rule) {\n cautils.list_contains(rule.resources,\"*\")\n isApiGroup(rule)\n cautils.list_contains(rule.verbs,\"*\")\n}\n\ncanDeleteLogs(rule) {\n cautils.list_contains(rule.resources,\"pods/log\")\n cautils.list_contains(rule.verbs,\"delete\")\n}\ncanDeleteLogs(rule) {\n cautils.list_contains(rule.resources,\"pods/log\")\n cautils.list_contains(rule.verbs,\"*\")\n}\n\ncanDeleteLogs(rule) {\n cautils.list_contains(rule.resources,\"*\")\n isApiGroup(rule)\n cautils.list_contains(rule.verbs,\"delete\")\n}\n\ncanDeleteLogs(rule) {\n cautils.list_contains(rule.resources,\"pods/*\")\n cautils.list_contains(rule.verbs,\"delete\")\n}\ncanDeleteLogs(rule) {\n cautils.list_contains(rule.resources,\"pods/*\")\n cautils.list_contains(rule.verbs,\"*\")\n}\n\ncanDeleteLogs(rule) {\n cautils.list_contains(rule.resources,\"*\")\n isApiGroup(rule)\n cautils.list_contains(rule.verbs,\"deletecollection\")\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}"
    },
    {
        "name": "exposed-sensitive-interfaces",
        "attributes": {
            "microsoftK8sThreatMatrix": "Initial access::Exposed sensitive interfaces",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Service",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "kubernetes.api.client"
            }
        ],
        "configInputs": [
            "settings.postureControlInputs.servicesNames"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.servicesNames",
                "name": "Service names",
                "description": "Kubescape will look for the following services that exposes sensitive interfaces of common K8s projects/applications"
            }
        ],
        "description": "fails if known interfaces have exposed services",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\nimport data\n\n# loadbalancer\ndeny[msga] {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"LoadBalancer\"\n\n\twl := input[_]\n\tworkload_types = {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"Pod\", \"CronJob\"}\n\tworkload_types[wl.kind]\n\tresult := wl_connectedto_service(wl, service)\n    \n    # see default-config-inputs.json for list values\n    services_names := data.postureControlInputs.servicesNames\n\tservices_names[service.metadata.name]\n    # externalIP := service.spec.externalIPs[_]\n\texternalIP := service.status.loadBalancer.ingress[0].ip\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl, service]\n\t\t}\n\t}\n}\n\n\n# nodePort\n# get a pod connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n    \n    # see default-config-inputs.json for list values\n    services_names := data.postureControlInputs.servicesNames\n\tservices_names[service.metadata.name]\n    \n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\n\tresult := wl_connectedto_service(pod, service)\n\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod, service]\n\t\t}\n\t}\n} \n\n# nodePort\n# get a workload connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n    \n    # see default-config-inputs.json for list values\n    services_names := data.postureControlInputs.servicesNames\n\tservices_names[service.metadata.name]\n    \n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"CronJob\"}\n\tspec_template_spec_patterns[wl.kind]\n\n\tresult := wl_connectedto_service(wl, service)\n\n\tpods_resource := client.query_all(\"pods\")\n\tpod := pods_resource.body.items[_]\n\tmy_pods := [pod | startswith(pod.metadata.name, wl.metadata.name)]\n\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl, service]\n\t\t}\n\t}\n}\n\n# ====================================================================================\n\nwl_connectedto_service(wl, service) = paths{\n\tcount({x | service.spec.selector[x] == wl.metadata.labels[x]}) == count(service.spec.selector)\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}\n\nwl_connectedto_service(wl, service) = paths {\n\twl.spec.selector.matchLabels == service.spec.selector\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}\n"
    },
    {
        "name": "resources-cpu-limit-and-request",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "CPU limits and requests are not set.",
        "remediation": "Ensure CPU limits and requests are set.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if pod doas not have container with CPU-limit or request\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    container := pod.spec.containers[i]\n\tnot request_or_limit_cpu(container)\n\tfixPaths := [{\"path\": sprintf(\"spec.containers[%v].resources.limits.cpu\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}, \n\t\t\t\t{\"path\": sprintf(\"spec.containers[%v].resources.requests.cpu\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v does not have CPU-limit or request\", [ container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPaths,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if workload doas not have container with CPU-limit or request\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n    not request_or_limit_cpu(container)\n\tfixPaths := [{\"path\": sprintf(\"spec.template.spec.containers[%v].resources.limits.cpu\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}, \n\t\t\t\t{\"path\": sprintf(\"spec.template.spec.containers[%v].resources.requests.cpu\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have CPU-limit or request\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPaths,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if cronjob doas not have container with CPU-limit or request\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n    not request_or_limit_cpu(container)\n\tfixPaths := [{\"path\": sprintf(\"spec.jobTemplate.template.spec.containers[%v].resources.limits.cpu\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}, \n\t\t\t\t{\"path\": sprintf(\"spec.jobTemplate.template.spec.containers[%v].resources.requests.cpu\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\t\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have CPU-limit or request\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPaths,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nrequest_or_limit_cpu(container) {\n\tcontainer.resources.limits.cpu\n\tcontainer.resources.requests.cpu\n}\n"
    },
    {
        "name": "rule-can-ssh-to-pod-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Execution::SSH server running inside container",
            "armoBuiltin": true,
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod",
                    "Service"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "denies pods with SSH ports opened(22/222)",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: pod\n# apiversion: v1\n# does:\treturns the external facing services of that pod\n\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tpodns := pod.metadata.namespace\n\tpodname := pod.metadata.name\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n    path := \"metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == podns\n\tservice.spec.selector == filtered_labels\n    \n\thasSSHPorts(service)\n\n\twlvector = {\"name\": pod.metadata.name,\n\t\t\t\t\"namespace\": pod.metadata.namespace,\n\t\t\t\t\"kind\": pod.kind,\n\t\t\t\t\"relatedObjects\": service}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod %v/%v exposed by SSH services: %v\", [podns, podname, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n    }\n}\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tlabels := wl.spec.template.metadata.labels\n    path := \"spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n    path := \"spec.jobTemplate.spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 2222\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 2222\n}\n",
        "resourceEnumerator": "package armo_builtins\n\n# input: pod\n# apiversion: v1\n# does:\treturns the external facing services of that pod\n\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tpodns := pod.metadata.namespace\n\tpodname := pod.metadata.name\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n    path := \"metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == podns\n\tservice.spec.selector == filtered_labels\n    \n\thasSSHPorts(service)\n\n\twlvector = {\"name\": pod.metadata.name,\n\t\t\t\t\"namespace\": pod.metadata.namespace,\n\t\t\t\t\"kind\": pod.kind,\n\t\t\t\t\"relatedObjects\": service}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod %v/%v exposed by SSH services: %v\", [podns, podname, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n    }\n}\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tlabels := wl.spec.template.metadata.labels\n    path := \"spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n    path := \"spec.jobTemplate.spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": service}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n     }\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 2222\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 2222\n}\n"
    },
    {
        "name": "rule-can-update-configmap-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Lateral Movement::CoreDNS poisoning",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can update/patch the 'coredns' configmap",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Fails if user can modify all configmaps\ndeny [msga] {\n     subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n     rule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"update\", \"patch\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"configmaps\", \"*\"]\n     not rule.resourceNames\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can modify 'coredns' configmap\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": finalpath,\n\t\t  \"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}\n\n\n# Fails if user  can modify the 'coredns' configmap (default for coredns)\ndeny [msga] {\n     subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n     rule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"update\", \"patch\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"configmaps\", \"*\"]\n     cautils.list_contains(rule.resourceNames,\"coredns\")\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can modify 'coredns' configmap\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n          \"failedPaths\": finalpath,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}\n"
    },
    {
        "name": "k8s-audit-logs-enabled-cloud",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [],
                "apiVersions": [],
                "resources": []
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "container.googleapis.com",
                    "eks.amazonaws.com"
                ],
                "apiVersions": [
                    "v1"
                ],
                "resources": [
                    "ClusterDescribe"
                ]
            }
        ],
        "relevantCloudProviders": [
            "EKS",
            "GKE"
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Check if audit logs is enabled for GKE\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"container.googleapis.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"gke\"\t\n\tconfig := clusterConfig.data\n\t\n    # If enableComponents is empty, it will disable logging\n    # https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#loggingcomponentconfig\n\tisLoggingDisabled(config)\n\tmsga := {\n\t\t\"alertMessage\": \"audit logs is disabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n\n# Check if audit logs is enabled for EKS\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"eks.amazonaws.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"eks\"\t\n\tconfig := clusterConfig.data\n    # logSetup is an object representing the enabled or disabled Kubernetes control plane logs for your cluster.\n    # types - available cluster control plane log types\n    # https://docs.aws.amazon.com/eks/latest/APIReference/API_LogSetup.html\n    goodTypes := [logSetup  | logSetup =  config.Cluster.Logging.ClusterLogging[_];  isAuditLogs(logSetup)]\n    count(goodTypes) == 0\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"audit logs is disabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n\nisLoggingDisabled(clusterConfig) {\n\tnot clusterConfig.logging_config.component_config.enable_components\n}\nisLoggingDisabled(clusterConfig) {\n\tclusterConfig.logging_config.component_config.enable_components\n\tcount(clusterConfig.logging_config.component_config.enable_components) == 0\n}\n\nisAuditLogs(logSetup) {\n    logSetup.Enabled == true\n    cautils.list_contains(logSetup.Types, \"api\")\n}\n\nisAuditLogs(logSetup) {\n    logSetup.Enabled == true\n    cautils.list_contains(logSetup.Types, \"audit\")\n}\n\nisAuditLogs(logSetup) {\n    logSetup.enabled == true\n    cautils.list_contains(logSetup.Types, \"authenticator\")\n}"
    },
    {
        "name": "rule-can-create-modify-pod",
        "attributes": {
            "m$K8sThreatMatrix": "Execution::New container, Persistence::Backdoor container",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have create/modify  permissions on pods",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n\n\n# fails if user has create/modify access to pods \n# RoleBinding to Role\ndeny [msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateModifyToPodResource(rule)\n    canCreateModifyToPodVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t\"alertMessage\": sprintf(\"The following %v: %v can create/modify workloads\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# fails if user has create/modify access to pods \n# RoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateModifyToPodResource(rule)\n    canCreateModifyToPodVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t\"alertMessage\": sprintf(\"The following %v: %v can create/modify workloads\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# fails if user has create/modify access to pods \n# ClusterRoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n     clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n     clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateModifyToPodResource(rule)\n    canCreateModifyToPodVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v can create/modify workloads\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n\n\ncanCreateModifyToPodResource(rule){\n    cautils.list_contains(rule.resources,\"pods\")\n}\n\ncanCreateModifyToPodResource(rule){\n    cautils.list_contains(rule.resources,\"deployments\")\n}\n\ncanCreateModifyToPodResource(rule){\n    cautils.list_contains(rule.resources,\"daemonsets\")\n}\n\ncanCreateModifyToPodResource(rule){\n    cautils.list_contains(rule.resources,\"replicasets\")\n}\ncanCreateModifyToPodResource(rule){\n    cautils.list_contains(rule.resources,\"statefulsets\")\n}\ncanCreateModifyToPodResource(rule){\n    cautils.list_contains(rule.resources,\"jobs\")\n}\ncanCreateModifyToPodResource(rule){\n    cautils.list_contains(rule.resources,\"cronjobs\")\n}\ncanCreateModifyToPodResource(rule){\n    isApiGroup(rule)\n    cautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\ncanCreateModifyToPodVerb(rule) {\n    cautils.list_contains(rule.verbs, \"create\")\n}\n\ncanCreateModifyToPodVerb(rule) {\n    cautils.list_contains(rule.verbs, \"patch\")\n}\n\ncanCreateModifyToPodVerb(rule) {\n    cautils.list_contains(rule.verbs, \"update\")\n}\n\ncanCreateModifyToPodVerb(rule) {\n    cautils.list_contains(rule.verbs, \"*\")\n}\n"
    },
    {
        "name": "deny-RCE-vuln-image-pods",
        "attributes": {
            "m$K8sThreatMatrix": "Execution::Application Exploit (RCE)",
            "armoBuiltin": true,
            "armoOpa": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod",
                    "services"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines if pods has vulnerable image with remote code execution",
        "remediation": "",
        "ruleQuery": "package armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n    \n# ========= RCE : no service score 5 ================\ndeny[msga] {\n\tpod := input[_]\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 5,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 5,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 5,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# ======== RCE + service (not nodeport and not loadbalancer) 7 =====================\ndeny[msga] {\n\tpod := input[_]\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == pod.metadata.namespace\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnot np_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector, filtered_labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 7,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnot np_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 7,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    \n    }\n}\n# cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnot np_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 7,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# ======= RCE + service nodeport/loadbalancer 10 ===========================\ndeny[msga] {\n\tpod := input[_]\n\tcontainer := pod.spec.containers[i]\n\tpath := sprintf(\"spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == pod.metadata.namespace\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector, filtered_labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 10,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# workloads\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 10,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n# cronjobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v]\", [format_int(i, 10)])\n    res := armo.get_image_scan_summary({\"type\":\"imageTag\",\"value\":container.image,\"size\":1})\n\tscan := res[_]\n\n    is_unsafe_image(scan)\n\tscan.containersScanID\n\tvulnerabilities := armo.get_image_scan_details({\"containersScanID\":scan.containersScanID, \"fieldCreteria\":{\"description\":\"RCE|like,Remote Code Execution|like,remote code execution|like,remote command execution|like,Remote Command Execution|like,arbitrary code|like,code execution|like,Arbitrary Code|like,Code Execution|like,code injection|like,Code Injection|like,execute code|like,Execute Code|like,arbitrary command|like,Arbitrary Command|like,arbitrary commands|like,Arbitrary Commands|like,command injection|like,Command Injection|like,command execution|like,Command Execution|like,inject arbitrary commands|like,Inject Arbitrary Commands|like\"} })\n\tcount(vulnerabilities) > 0\n\tt := { \"containersScanID\": scan.containersScanID,\"count\":count(vulnerabilities),\"vulnerabilities\":vulnerabilities}\n\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n\tnp_or_lb := {\"NodePort\", \"LoadBalancer\"}\n\tnp_or_lb[service.spec.type]\n\tcautils.is_subobject(service.spec.selector,labels)\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has %v RCE vulnerabilities\", [container.image,count(vulnerabilities)]),\n        \"alertScore\": 10,\n\t\t\"fixPaths\":[],\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"vulnerabilities\" : [vulnerabilities]\n\t\t\t}\n\t\t},\n    }\n}\n\n#treat as potentially critical\nis_unsafe_image(scanresult) {\n\tscanresult.numOfUnknownSeverity > 0\n}\nis_unsafe_image(scanresult) {\n\tscanresult.numOfNegligibleSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfLowSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfMeduiumSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfHighSeverity > 0\n}\n\nis_unsafe_image(scanresult) {\n\tscanresult.numOfCriticalSeverity > 0\n}"
    },
    {
        "name": "automount-service-account",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Serviceaccount",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if service account and workloads mount service account token by default",
        "remediation": "Make sure that the automountServiceAccountToken field on the service account spec if set to false",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# Fails if user account mount tokens in pod by default\ndeny [msga]{\n    serviceaccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceaccounts[_]\n    result := isAutoMount(serviceaccount)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"the following service account: %v in the following namespace: %v mounts service account tokens in pods by default\", [serviceaccount.metadata.name, serviceaccount.metadata.namespace]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [serviceaccount]\n\t\t}\n\t}\n}    \n\n\n #  -- ----     For workloads     -- ----   \n# Fails if pod mount tokens  by default (either by its config or by its SA config)\n\n # POD  \ndeny [msga]{\n    pod := input[_]\n\tpod.kind == \"Pod\"\n\n\tbegginingOfPath := \"spec.\"\n\twlNamespace := pod.metadata.namespace\n\tresult := isSAAutoMounted(pod.spec, begginingOfPath, wlNamespace)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"Pod: %v in the following namespace: %v mounts service account tokens by default\", [pod.metadata.name, pod.metadata.namespace]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}    \n\n# WORKLOADS\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tbegginingOfPath := \"spec.template.spec.\"\n\n\twlNamespace := wl.metadata.namespace\n\tresult := isSAAutoMounted(wl.spec.template.spec, begginingOfPath, wlNamespace)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\tmsga := {\n\t\t\"alertMessage\":  sprintf(\"%v: %v in the following namespace: %v mounts service account tokens by default\", [wl.kind, wl.metadata.name, wl.metadata.namespace]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# CRONJOB\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n   \n\twlNamespace := wl.metadata.namespace\n\tresult := isSAAutoMounted(wl.spec.jobTemplate.spec.template.spec, begginingOfPath, wlNamespace)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v in the following namespace: %v mounts service account tokens by default\", [wl.kind, wl.metadata.name, wl.metadata.namespace]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\n #  -- ----     For workloads     -- ----     \nisSAAutoMounted(spec, begginingOfPath, wlNamespace) = [failedPath, fixPath]   {\n\t# automountServiceAccountToken not in pod spec\n\tnot spec.automountServiceAccountToken == false\n\tnot spec.automountServiceAccountToken == true\n\n\t# check if SA  automount by default\n\tsa := input[_]\n\tisSameSA(spec, sa.metadata.name)\n\tisSameNamespace(sa.metadata.namespace , wlNamespace)\n\tnot sa.automountServiceAccountToken == false\n\n\t# path is pod spec\n\tfixPath = { \"path\": sprintf(\"%vautomountServiceAccountToken\", [begginingOfPath]), \"value\": \"false\"}\n\tfailedPath = \"\"\n}\n\ngetFailedPath(paths) = [paths[0]] {\n\tpaths[0] != \"\"\n} else = []\n\n\ngetFixedPath(paths) = [paths[1]] {\n\tpaths[1] != \"\"\n} else = []\n\nisSAAutoMounted(spec, begginingOfPath, wlNamespace) =  [failedPath, fixPath]  {\n\t# automountServiceAccountToken set to true in pod spec\n\tspec.automountServiceAccountToken == true\n\t\n\t# SA automount by default\n\tserviceaccounts := [serviceaccount | serviceaccount = input[_]; serviceaccount.kind == \"ServiceAccount\"]\n\tcount(serviceaccounts) > 0\n\tsa := serviceaccounts[_]\n\tisSameSA(spec, sa.metadata.name)\n\tisSameNamespace(sa.metadata.namespace , wlNamespace)\n\tnot sa.automountServiceAccountToken == false\n\n\tfailedPath = sprintf(\"%vautomountServiceAccountToken\", [begginingOfPath])\n\tfixPath = \"\"\n}\n\nisSAAutoMounted(spec, begginingOfPath, wlNamespace) =  [failedPath, fixPath]  {\n\t# automountServiceAccountToken set to true in pod spec\n\tspec.automountServiceAccountToken == true\n\t\n\t# No SA (yaml scan)\n\tserviceaccounts := [serviceaccount | serviceaccount = input[_]; serviceaccount.kind == \"ServiceAccount\"]\n\tcount(serviceaccounts) == 0\n\tfailedPath = sprintf(\"%vautomountServiceAccountToken\", [begginingOfPath])\n\tfixPath = \"\"\n}\n\n\n\n #  -- ----     For SAs     -- ----     \nisAutoMount(serviceaccount)  =  [failedPath, fixPath]  {\n\tserviceaccount.automountServiceAccountToken == true\n\tfailedPath = \"automountServiceAccountToken\"\n\tfixPath = \"\"\n}\n\nisAutoMount(serviceaccount)=  [failedPath, fixPath]  {\n\tnot serviceaccount.automountServiceAccountToken == false\n\tnot serviceaccount.automountServiceAccountToken == true\n\tfixPath = {\"path\": \"automountServiceAccountToken\", \"value\": \"false\"}\n\tfailedPath = \"\"\n}\n\nisSameSA(spec, serviceAccountName) {\n\tspec.serviceAccountName == serviceAccountName\n}\n\nisSameSA(spec, serviceAccountName) {\n\tnot spec.serviceAccountName \n\tserviceAccountName == \"default\"\n}\n\n\nisSameNamespace(metadata1, metadata2) {\n\tmetadata1.namespace == metadata2.namespace\n}\n\nisSameNamespace(metadata1, metadata2) {\n\tnot metadata1.namespace\n\tnot metadata2.namespace\n}\n\nisSameNamespace(metadata1, metadata2) {\n\tnot metadata2.namespace\n\tmetadata1.namespace == \"default\"\n}\n\nisSameNamespace(metadata1, metadata2) {\n\tnot metadata1.namespace\n\tmetadata2.namespace == \"default\"\n}"
    },
    {
        "name": "sidecar-injection",
        "attributes": {
            "m$K8sThreatMatrix": "Execution::Sidecar injection",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pods",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if container lifecycle field is set to sidecar, or if container name includes 'sidecar'.",
        "remediation": "",
        "ruleQuery": "",
        "rule": "package armo_builtins\n\n# =========== looks for containers with lifecycle.type \"Sidecar\" ===========\n#pods\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tcontainer.lifecycle.type == \"Sidecar\"\n\tpath := sprintf(\"spec.containers[%v].lifecycle.type\", [format_int(i, 10)])\n    msga := {\n\t\t\"alertMessage\": sprintf(\"The pod: %v has a sidecar: %v\", [pod.metadata.name, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n     }\n}\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tcontainer.lifecycle.type == \"Sidecar\"\n\tpath := sprintf(\"spec.template.spec.containers[%v].lifecycle.type\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has a sidecar: %v\", [wl.kind, wl.metadata.name, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n#handles cronjob\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tcontainer.lifecycle.type == \"Sidecar\"\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].lifecycle.type\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has a sidecar: %v\", [wl.metadata.name, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n\n# =========== looks for containers \"sidecar\" in name ===========\n#pods\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n    contains(lower(container.name), \"sidecar\")\n\tpath := sprintf(\"spec.containers[%v].name\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"The pod: %v has a sidecar: %v\", [pod.metadata.name, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n     }\n}\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tcontains(lower(container.name), \"sidecar\")\n\tpath := sprintf(\"spec.template.spec.containers[%v].name\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has a sidecar: %v\", [wl.kind, wl.metadata.name, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n#handles cronjob\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tcontains(lower(container.name), \"sidecar\")\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].name\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has a sidecar: %v\", [wl.metadata.name, container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": [path],\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}"
    },
    {
        "name": "access-container-service-account",
        "attributes": {
            "m$K8sThreatMatrix": "Credential Access::Access container service account, Lateral Movement::Container service account",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob",
                    "ServiceAccounts",
                    "RoleBinding",
                    "ClusterRoleBinding",
                    "Role",
                    "ClusterRole"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "determines which service accounts can be used to access other resources in the cluster",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\n\n\n# Returns for each Pod, what are the permission of its service account\n\ndeny[msga] {\n   serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n    \n    pods := [pod | pod=input[_]; pod.kind ==\"Pod\"]\n    pod := pods[_]\n    pod.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, pod)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has the following permissions in the cluster: %v\", [pod.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [\"\"],\n\t\t\"alertScore\": 7,\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, pod]\n\t\t}\n\t}\n}\n\n# Returns for each Pod, what are the permission of its service account\n deny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    pods := [pod | pod=input[_]; pod.kind ==\"Pod\"]\n    pod := pods[_]\n    pod.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, pod)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has the following permissions in the cluster: %v\", [pod.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n         \"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [rolebinding, role, pod]\n\t\t}\n\t}\n}\n\n# Returns for each Pod, what are the permission of its service account\n\n deny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    pods := [pod | pod=input[_]; pod.kind ==\"Pod\"]\n    pod := pods[_]\n    pod.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, pod)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has the following permissions in the cluster: %v\", [pod.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n         \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, pod]\n\t\t}\n\t}\n}\n\n\n\n\n### ---------------- #####\n\n \n\n# Returns for each Workloads, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\n    wl.spec.template.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has the following permissions in the cluster: %v\", [wl.kind, wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n# Returns for each Workloads, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\n    wl.spec.template.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n        msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has the following permissions in the cluster: %v\", [wl.kind, wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n\n# Returns for each Workloads, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\n    wl.spec.template.spec.serviceAccountName == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\n        msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has the following permissions in the cluster: %v\", [wl.kind, wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n\n\n### ---------------- #####\n\n\n# Returns for each Cronjob, what are the permission of its service account\n\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\twl.spec.jobTemplate.spec.template.spec.serviceAccountName  == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.jobTemplate.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has the following permissions in the cluster: %v\", [wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n\n# Returns for each Cronjob, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\twl.spec.jobTemplate.spec.template.spec.serviceAccountName  == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.jobTemplate.spec.template)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has the following permissions in the cluster: %v\", [wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n\n# Returns for each Cronjob, what are the permission of its service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\twl.spec.jobTemplate.spec.template.spec.serviceAccountName  == serviceAccountName\n\n    not isNotAutoMount(serviceaccount, wl.spec.jobTemplate.spec.template)\n     \n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v has the following permissions in the cluster: %v\", [wl.metadata.name, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [rolebinding, role, wl]\n\t\t}\n\t}\n}\n\n# ===============================================================\n\nisNotAutoMount(serviceaccount, pod) {\n    pod.spec.automountServiceAccountToken == false\n}\nisNotAutoMount(serviceaccount, pod) {\n    serviceaccount.automountServiceAccountToken == false\n    not pod.spec[\"automountServiceAccountToken\"]\n}\n\n"
    },
    {
        "name": "rule-can-list-get-secrets",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can list/get secrets",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n\n# fails if user can list/get secrets \n#RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canViewSecretsResource(rule)\n    canViewSecretsVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can read secrets\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can list/get secrets \n#RoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canViewSecretsResource(rule)\n    canViewSecretsVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can read secrets\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [path],\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# fails if user can list/get secrets \n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canViewSecretsResource(rule)\n    canViewSecretsVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can read secrets\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"get\")\n}\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"list\")\n}\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"watch\")\n}\n\n\ncanViewSecretsVerb(rule) {\n    cautils.list_contains(rule.verbs,\"*\")\n}\n\n\ncanViewSecretsResource(rule) {\n    cautils.list_contains(rule.resources,\"secrets\")\n}\n\ncanViewSecretsResource(rule) {\n    isApiGroup(rule)\n    cautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}"
    },
    {
        "name": "list-all-mutating-webhooks",
        "attributes": {
            "m$K8sThreatMatrix": "Persistence::Malicious admission controller",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "MutatingWebhookConfiguration"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Returns mutating webhook configurations to be verified",
        "remediation": "Analyze webhook for malicious behavior",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny [msga] {\n    mutatingwebhooks := [mutatingwebhook | mutatingwebhook = input[_]; mutatingwebhook.kind == \"MutatingWebhookConfiguration\"]\n    mutatingwebhook := mutatingwebhooks[_]\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following mutating webhook configuration should be checked %v.\", [mutatingwebhook.metadata.name]),\n\t\t\"alertScore\": 6,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [mutatingwebhook]\n\t\t}\n\t}\n}"
    },
    {
        "name": "insecure-capabilities",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "configInputs": [
            "settings.postureControlInputs.insecureCapabilities"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.insecureCapabilities",
                "name": "Insecure capabilities",
                "description": "You can see the list of capabilities in https://man7.org/linux/man-pages/man7/capabilities.7.html. Kubescape looks for the following capabilities in containers which might lead to attackers getting high privileges in your system."
            }
        ],
        "description": "fails if container has insecure capabilities",
        "remediation": "Remove all insecure capabilities which aren\u2019t necessary for the container.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data\nimport data.cautils as cautils\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n    result := isDangerousCapabilities(container, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  have dangerous capabilities\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result := isDangerousCapabilities(container, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in workload: %v  have dangerous capabilities\", [container.name, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n    result := isDangerousCapabilities(container, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in cronjob: %v  have dangerous capabilities\", [container.name, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nisDangerousCapabilities(container, begginingOfPath, i) = path {\n\t# see default-config-inputs.json for list values\n    insecureCapabilities := data.postureControlInputs.insecureCapabilities\n\tpath = [sprintf(\"%vcontainers[%v].securityContext.capabilities.add[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) | capability = container.securityContext.capabilities.add[k]; cautils.list_contains(insecureCapabilities, capability)]\n\tcount(path) > 0\n}"
    },
    {
        "name": "rule-excessive-delete-rights-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Impact::Data Destruction",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if user can delete important resources",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can can delete important resources\ndeny[msga] {\n    subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"delete\", \"deletecollection\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\", \"apps\", \"batch\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"secrets\", \"pods\", \"services\", \"deployments\", \"replicasets\", \"daemonsets\", \"statefulsets\", \"jobs\",\"cronjobs\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can delete important resources\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": finalpath,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}"
    },
    {
        "name": "alert-rw-hostpath",
        "attributes": {
            "m$K8sThreatMatrix": "Persistance::Writable hostPath mount, Lateral Movement::Writable volume mounts on the host",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            },
            {
                "packageName": "kubernetes.api.client"
            }
        ],
        "description": "determines if any workload contains a hostPath volume with rw permissions",
        "remediation": "Set the readOnly field of the mount to true",
        "ruleQuery": "",
        "rule": "package armo_builtins\n\n# Fails if container has a hostPath volume which is not readOnly\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    volumes := pod.spec.volumes\n    volume := volumes[_]\n    volume.hostPath\n\tcontainer := pod.spec.containers[i]\n\tvolumeMount := container.volumeMounts[k]\n\tvolumeMount.name == volume.name\n\tbegginingOfPath := \"spec.\"\n\tresult := isRWMount(volumeMount, begginingOfPath,  i, k)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n    podname := pod.metadata.name\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod: %v has: %v as hostPath volume\", [podname, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    volumes := wl.spec.template.spec.volumes\n    volume := volumes[_]\n    volume.hostPath\n\tcontainer := wl.spec.template.spec.containers[i]\n\tvolumeMount := container.volumeMounts[k]\n\tvolumeMount.name == volume.name\n\tbegginingOfPath := \"spec.template.spec.\"\n\tresult := isRWMount(volumeMount, begginingOfPath,  i, k)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"failedPaths\": failedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t\n\t}\n}\n\n#handles CronJobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    volumes := wl.spec.jobTemplate.spec.template.spec.volumes\n    volume := volumes[_]\n    volume.hostPath\n\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tvolumeMount := container.volumeMounts[k]\n\tvolumeMount.name == volume.name\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tresult := isRWMount(volumeMount, begginingOfPath,  i, k) \n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\n\tmsga := {\n\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\"packagename\": \"armo_builtins\",\n\t\"alertScore\": 7,\n\t\"fixPaths\": fixedPath,\n\t\"failedPaths\": failedPath,\n\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\ngetFailedPath(paths) = [paths[0]] {\n\tpaths[0] != \"\"\n} else = []\n\n\ngetFixedPath(paths) = [paths[1]] {\n\tpaths[1] != \"\"\n} else = []\n\n\nisRWMount(mount, begginingOfPath,  i, k) =  [failedPath, fixPath] {\n\tnot mount.readOnly == true\n \tnot mount.readOnly == false\n\tfailedPath = \"\"\n    fixPath = {\"path\": sprintf(\"%vcontainers[%v].volumeMounts[%v].readOnly\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]), \"value\":\"true\"}\n}\n\nisRWMount(mount, begginingOfPath,  i, k) =  [failedPath, fixPath] {\n  \tmount.readOnly == false\n  \tfailedPath = sprintf(\"%vcontainers[%v].volumeMounts[%v].readOnly\", [begginingOfPath, format_int(i, 10), format_int(k, 10)])\n    fixPath = \"\"\n} "
    },
    {
        "name": "access-tiller-endpoint",
        "attributes": {
            "microsoftK8sThreatMatrix": "Lateral movement::Access tiller endpoint",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if tiller exists in cluster",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: deployment\n# fails if tiller exists in cluster\n\ndeny[msga] {\n\tdeployment := \tinput[_]\n\tdeployment.kind == \"Deployment\"\n    deployment.metadata.name == \"tiller-deploy\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"tiller exists in namespace: %v\", [deployment.metadata.namespace]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [\"metadata.name\"],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [deployment]\n\t\t}\n\t}\n}",
        "resourceEnumerator": "package armo_builtins\n\n# input: deployment\n# fails if tiller exists in cluster\n\ndeny[msga] {\n\tdeployment := \tinput[_]\n\tdeployment.kind == \"Deployment\"\n    deployment.metadata.name == \"tiller-deploy\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"tiller exists in namespace: %v\", [deployment.metadata.namespace]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [\"metadata.name\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [deployment]\n\t\t}\n\t}\n}"
    },
    {
        "name": "rule-list-all-cluster-admins",
        "attributes": {
            "m$K8sThreatMatrix": "Privilege Escalation::Cluster-admin binding",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have cluster admin permissions",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# input: roles\n# apiversion: v1\n# does: returns roles+ related subjects in rolebinding\n\ndeny[msga] {\n\troles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[i]\n\tcanCreate(rule, i)\n\tcanCreateResources(rule, i)\n\n\trolebinding.roleRef.kind == \"Role\"\n\trolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v have high privileges, such as cluster-admin\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# input: ClusterRole\n# apiversion: v1\n# does: returns clusterroles+ related subjects in rolebinding\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[i]\n\tcanCreate(rule, i)\n\tcanCreateResources(rule, i)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n    \n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v have high privileges, such as cluster-admin\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# input: ClusterRole\n# apiversion: v1\n# does:\treturns clusterroles+ related subjects in clusterrolebinding\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[i]\n\tcanCreate(rule, i)\n    canCreateResources(rule, i)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following %v: %v have high privileges, such as cluster-admin\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ncanCreate(rule, i) {\n\tverb := rule.verbs[j]\n\tverb == \"*\"\n}\n\ncanCreateResources(rule, i){\n\tisApiGroup(rule)\n\tresource := rule.resources[j]\n\tresource == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n"
    },
    {
        "name": "security-context-in-pod",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if pod/container does not define a security context.",
        "remediation": "Make sure that the securityContext field is defined for pod/container.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    container := pod.spec.containers[i]\n    isNotSecurityContext(pod, container)\n\tfixPaths := [{\"path\": sprintf(\"spec.containers[%v].securityContext\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in pod: %v does not define a securityContext.\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPaths,\n\t\t\"alertScore\": 7,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\t\n}\n\n\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tisNotSecurityContext(wl.spec.template, container)\n\tfixPaths := [{\"path\": sprintf(\"spec.template.spec.containers[%v].securityContext\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v does not define a securityContext.\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPaths,\n\t\t\"alertScore\": 7,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tisNotSecurityContext(wl.spec.jobTemplate.spec.template, container)\n\tfixPaths := [{\"path\": sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].securityContext\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v does not define a securityContext.\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPaths,\n\t\t\"alertScore\": 7,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\nisNotSecurityContext(pod, container) {\n\tnot pod.spec.securityContext \n\tnot container.securityContext\n}\n\nisNotSecurityContext(pod, container) {\n\tcount(pod.spec.securityContext) == 0\n\tnot container.securityContext\n}\n\n\nisNotSecurityContext(pod, container) {\n\tnot pod.spec.securityContext \n\tcontainer.securityContext\n\tcount(container.securityContext) == 0\n}\n\nisNotSecurityContext(pod, container) {\n   \tcount(pod.spec.securityContext) == 0\n   \tcontainer.securityContext\n  \tcount(container.securityContext) == 0\n}"
    },
    {
        "name": "rule-access-kubelet-API",
        "attributes": {
            "m$K8sThreatMatrix": "Discovery::Access Kubelet API",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "networkpolicies"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if no network policy exists",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: network policies\n# apiversion: networking.k8s.io/v1\n# fails if no network policies are defined\n\ndeny[msga] {\n\tnetworkpolicies := input\n    count(networkpolicies) == 0\n\n\tmsga := {\n\t\t\"alertMessage\": \"no network policy is defined\",\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\n\t\t}\n\t}\n}"
    },
    {
        "name": "ingress-and-egress-blocked",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob",
                    "NetworkPolicy"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if there are no ingress and egress defined for pod",
        "remediation": "Make sure you define ingress and egress policies for all your Pods",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# For pods\ndeny[msga] {\n \t\tpods := [pod |  pod= input[_]; pod.kind == \"Pod\"]\n\t\tnetworkpolicies := [networkpolicie |  networkpolicie= input[_]; networkpolicie.kind == \"NetworkPolicy\"]\n\t\tpod := pods[_]\n\t\tnetworkpoliciesConnectedToPod := [networkpolicie |  networkpolicie= networkpolicies[_];  podConnectedToNetworkPolicy(pod, networkpolicie)]\n\t\tcount(networkpoliciesConnectedToPod) > 0\n        goodPolicies := [goodpolicie |  goodpolicie= networkpoliciesConnectedToPod[_];  isIngerssEgressPolicy(goodpolicie)]\n\t\tcount(goodPolicies) < 1\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v does not have ingress/egress defined\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n\n}\n\n# For pods\ndeny[msga] {\n \t\tpods := [pod |  pod= input[_]; pod.kind == \"Pod\"]\n\t\tnetworkpolicies := [networkpolicie |  networkpolicie= input[_]; networkpolicie.kind == \"NetworkPolicy\"]\n\t\tpod := pods[_]\n\t\tnetworkpoliciesConnectedToPod := [networkpolicie |  networkpolicie= networkpolicies[_];  podConnectedToNetworkPolicy(pod, networkpolicie)]\n\t\tcount(networkpoliciesConnectedToPod) < 1\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v does not have ingress/egress defined\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n\n}\n\n# For workloads\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    networkpolicies := [networkpolicie |  networkpolicie= input[_]; networkpolicie.kind == \"NetworkPolicy\"]\n\tnetworkpoliciesConnectedToPod := [networkpolicie |  networkpolicie= networkpolicies[_];  wlConnectedToNetworkPolicy(wl, networkpolicie)]\n\tcount(networkpoliciesConnectedToPod) > 0\n    goodPolicies := [goodpolicie |  goodpolicie= networkpoliciesConnectedToPod[_];  isIngerssEgressPolicy(goodpolicie)]\n\tcount(goodPolicies) < 1\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has Pods which don't have ingress/egress defined\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# For workloads\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    networkpolicies := [networkpolicie |  networkpolicie= input[_]; networkpolicie.kind == \"NetworkPolicy\"]\n\tnetworkpoliciesConnectedToPod := [networkpolicie |  networkpolicie= networkpolicies[_];  wlConnectedToNetworkPolicy(wl, networkpolicie)]\n\tcount(networkpoliciesConnectedToPod) < 1\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has Pods which don't have ingress/egress defined\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# For Cronjobs\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    networkpolicies := [networkpolicie |  networkpolicie= input[_]; networkpolicie.kind == \"NetworkPolicy\"]\n\tnetworkpoliciesConnectedToPod := [networkpolicie |  networkpolicie= networkpolicies[_];  cronjobConnectedToNetworkPolicy(wl, networkpolicie)]\n\tcount(networkpoliciesConnectedToPod) > 0\n    goodPolicies := [goodpolicie |  goodpolicie= networkpoliciesConnectedToPod[_];  isIngerssEgressPolicy(goodpolicie)]\n\tcount(goodPolicies) < 1\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has Pods which don't have ingress/egress defined\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n# For Cronjobs\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    networkpolicies := [networkpolicie |  networkpolicie= input[_]; networkpolicie.kind == \"NetworkPolicy\"]\n\tnetworkpoliciesConnectedToPod := [networkpolicie |  networkpolicie= networkpolicies[_];  cronjobConnectedToNetworkPolicy(wl, networkpolicie)]\n\tcount(networkpoliciesConnectedToPod) < 1\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has Pods which don't have ingress/egress defined\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nisSameNamespace(metadata1, metadata2) {\n\tmetadata1.namespace == metadata2.namespace\n}\n\nisSameNamespace(metadata1, metadata2) {\n\tnot metadata1.namespace\n\tnot metadata2.namespace\n}\n\nisSameNamespace(metadata1, metadata2) {\n\tnot metadata2.namespace\n\tmetadata1.namespace == \"default\"\n}\n\nisSameNamespace(metadata1, metadata2) {\n\tnot metadata1.namespace\n\tmetadata2.namespace == \"default\"\n}\n\npodConnectedToNetworkPolicy(pod, networkpolicie){\n\tisSameNamespace(networkpolicie.metadata, pod.metadata)\n    count(networkpolicie.spec.podSelector) > 0\n    count({x | networkpolicie.spec.podSelector.matchLabels[x] == pod.metadata.labels[x]}) == count(networkpolicie.spec.podSelector.matchLabels)\n}\n\npodConnectedToNetworkPolicy(pod, networkpolicie){\n\tisSameNamespace(networkpolicie.metadata ,pod.metadata)\n    count(networkpolicie.spec.podSelector) == 0\n}\n\nwlConnectedToNetworkPolicy(wl, networkpolicie){\n\tisSameNamespace(wl.metadata , networkpolicie.metadata)\n    count(networkpolicie.spec.podSelector) == 0\n}\n\n\nwlConnectedToNetworkPolicy(wl, networkpolicie){\n\tisSameNamespace(wl.metadata, networkpolicie.metadata)\n\tcount(networkpolicie.spec.podSelector) > 0\n    count({x | networkpolicie.spec.podSelector.matchLabels[x] == wl.spec.template.metadata.labels[x]}) == count(networkpolicie.spec.podSelector.matchLabels)\n}\n\n\ncronjobConnectedToNetworkPolicy(cj, networkpolicie){\n\tisSameNamespace(cj.metadata , networkpolicie.metadata)\n    count(networkpolicie.spec.podSelector) == 0\n}\n\ncronjobConnectedToNetworkPolicy(cj, networkpolicie){\n\tisSameNamespace(cj.metadata , networkpolicie.metadata)\n\tcount(networkpolicie.spec.podSelector) > 0\n    count({x | networkpolicie.spec.podSelector.matchLabels[x] == cj.spec.jobTemplate.spec.template.metadata.labels[x]}) == count(networkpolicie.spec.podSelector.matchLabels)\n}\n\nisIngerssEgressPolicy(networkpolicie) {\n    list_contains(networkpolicie.spec.policyTypes, \"Ingress\")\n    list_contains(networkpolicie.spec.policyTypes, \"Egress\")\n }\n\nlist_contains(list, element) {\n  some i\n  list[i] == element\n}"
    },
    {
        "name": "rule-can-delete-create-service",
        "attributes": {
            "m$K8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have create/delete  permissions on services",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n\n\n# fails if user has create/delete access to services\n# RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateDeleteToServiceResource(rule)\n    canCreateDeleteToServiceVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can create/delete  services\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# fails if user has create/delete access to services\n# RoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\n    canCreateDeleteToServiceResource(rule)\n    canCreateDeleteToServiceVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can create/delete  services\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n\n}\n\n# fails if user has create/delete access to services\n# ClusterRoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n     clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n     clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n\n    canCreateDeleteToServiceResource(rule)\n    canCreateDeleteToServiceVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can create/delete  services\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\ncanCreateDeleteToServiceResource(rule) {\n    cautils.list_contains(rule.resources, \"services\")\n}\n\ncanCreateDeleteToServiceResource(rule) {\n    isApiGroup(rule)\n    cautils.list_contains(rule.resources, \"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\ncanCreateDeleteToServiceVerb(rule) {\n     cautils.list_contains(rule.verbs, \"create\")\n}\n\ncanCreateDeleteToServiceVerb(rule) {\n     cautils.list_contains(rule.verbs, \"delete\")\n}\n\ncanCreateDeleteToServiceVerb(rule) {\n     cautils.list_contains(rule.verbs, \"deletecollection\")\n}\n\ncanCreateDeleteToServiceVerb(rule) {\n     cautils.list_contains(rule.verbs, \"*\")\n}"
    },
    {
        "name": "pods-in-default-namespace",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\", \"Job\", \"CronJob\", \"Pod\"}\n\tspec_template_spec_patterns[wl.kind]\n\tresult := isDefaultNamespace(wl.metadata)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has pods running in the 'default' namespace\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\nisDefaultNamespace(metadata) = [failedPath, fixPath] {\n\tmetadata.namespace == \"default\"\n\tfailedPath = \"metadata.namespace\"\n\tfixPath = \"\" \n}\n\n\nisDefaultNamespace(metadata) = [failedPath, fixPath] {\n\tnot metadata.namespace \n\tfixPath = {\"path\": \"metadata.namespace\", \"value\": \"YOUR_VALUE\"} \n\tfailedPath = \"\" \n}\n\ngetFailedPath(paths) = [paths[0]] {\n\tpaths[0] != \"\"\n} else = []\n\n\ngetFixedPath(paths) = [paths[1]] {\n\tpaths[1] != \"\"\n} else = []\n\n\n"
    },
    {
        "name": "namespace-without-service-account",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Namespace",
                    "ServiceAccount"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if namespace does not have service accounts (not incluiding default)",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if namespace does not have service accounts (not incluiding default)\ndeny[msga] {\n\tnamespace := input[_]\n\tnamespace.kind == \"Namespace\"\n\tserviceAccounts := [serviceaccount |  serviceaccount= input[_]; isGoodSA(serviceaccount, namespace.metadata.name)]\n\tcount(serviceAccounts) < 1\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Namespace: %v does not have any service accounts besides 'default'\", [namespace.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [namespace]\n\t\t}\n\t}\n}\n\t\n\t\nisGoodSA(sa, namespace) { \n\tsa.kind == \"ServiceAccount\"\n\tsa.metadata.namespace == namespace\n\tsa.metadata.name != \"default\"\n}"
    },
    {
        "name": "enforce-kubelet-client-tls-authentication",
        "attributes": {
            "armoBuiltin": true,
            "hostSensorRule": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [],
                "apiVersions": [],
                "resources": []
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "hostdata.kubescape.cloud"
                ],
                "apiVersions": [
                    "v1beta0"
                ],
                "resources": [
                    "KubeletConfiguration",
                    "KubeletCommandLine"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            },
            {
                "packageName": "kubernetes.api.client"
            }
        ],
        "description": "Determines if kubelet client tls authentication is enabled.",
        "remediation": "Start the kubelet with the --client-ca-file flag, providing a CA bundle to verify client certificates with.",
        "ruleQuery": "",
        "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\t\tkubeletCliData := kubeletCli.data\n\n\n\t\tisClientTlsDisabled(kubeletConfig, kubeletCliData)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"kubelet client TLS authentication is not enabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"failedPaths\": [],\n\t\t\t\"fixPaths\":[],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [kubeletConfig, kubeletCli]\n\t\t\t},\n\t\t}\n\t}\n\n# CLI overrides config\nisClientTlsDisabled(kubeletConfig, kubeletCliData) {\n\tnot contains(kubeletCliData[\"fullCommand\"], \"client-ca-file\")\n    not kubeletConfig.data.authentication.x509.clientCAFile\n}\n"
    },
    {
        "name": "rule-privilege-escalation",
        "attributes": {
            "m$K8sThreatMatrix": "Privilege Escalation::privileged container",
            "mitre": "Privilege Escalation",
            "mitreCode": "TA0004",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "determines if pods/deployments defined as privileged true",
        "remediation": "avoid defining pods as privilleged",
        "ruleQuery": "",
        "rule": "package armo_builtins\n# Deny mutating action unless user is in group owning the resource\n\n\n#privileged pods\ndeny[msga] {\n\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n\tpath := isPrivilegedContainer(container, i, begginingOfPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following pods are defined as privileged: %v\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": path,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n     }\n}\n\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n\tpath := isPrivilegedContainer(container, i, begginingOfPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is defined as privileged:\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": path,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n#handles cronjob\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tpath := isPrivilegedContainer(container, i, begginingOfPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjobs are defined as privileged: %v\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": path,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n\n# Only SYS_ADMIN capabilite\nisPrivilegedContainer(container, i, begginingOfPath) = path {\n\tnot container.securityContext.privileged == true\n\tpath = [sprintf(\"%vcontainers[%v].securityContext.capabilities.add[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) | capabilite = container.securityContext.capabilities.add[k]; capabilite == \"SYS_ADMIN\"]\n\tcount(path) > 0\n}\n\n# Only securityContext.privileged == true\nisPrivilegedContainer(container, i, begginingOfPath) = path {\n\tcontainer.securityContext.privileged == true\n\tpath1 = [sprintf(\"%vcontainers[%v].securityContext.capabilities.add[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) | capabilite = container.securityContext.capabilities.add[k]; capabilite == \"SYS_ADMIN\"]\n\tcount(path1) < 1\n\tpath = [sprintf(\"%vcontainers[%v].securityContext.privileged\", [begginingOfPath, format_int(i, 10)])]\n}\n\n# SYS_ADMIN capabilite && securityContext.privileged == true\nisPrivilegedContainer(container, i, begginingOfPath) = path {\n\tpath1 = [sprintf(\"%vcontainers[%v].securityContext.capabilities.add[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) | capabilite = container.securityContext.capabilities.add[k]; capabilite == \"SYS_ADMIN\"]\n\tcount(path1) > 0\n\tcontainer.securityContext.privileged == true\n\tpath = array.concat(path1, [sprintf(\"%vcontainers[%v].securityContext.privileged\", [begginingOfPath, format_int(i, 10)])])\n}"
    },
    {
        "name": "insecure-port-flag",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if the api server has insecure-port enabled",
        "remediation": "Make sure that the insecure-port flag of the api server is set to 0",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Fails if pod has insecure-port flag enabled\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontains(pod.metadata.name, \"kube-apiserver\")\n    container := pod.spec.containers[i]\n\tpath = isInsecurePortFlag(container, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"The API server container: %v has insecure-port flag enabled\", [ container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\t\nisInsecurePortFlag(container, i) = path {\n\tcommand := container.command[j]\n\tcontains(command, \"--insecure-port=1\")\n\tpath := sprintf(\"spec.containers[%v].command[%v]\", [format_int(i, 10), format_int(j, 10)])\n}",
        "resourceEnumerator": "package armo_builtins\nimport data.cautils as cautils\n\n# Fails if pod has insecure-port flag enabled\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontains(pod.metadata.name, \"kube-apiserver\")\n    container := pod.spec.containers[_]\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"The API server container: %v has insecure-port flag enabled\", [ container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n"
    },
    {
        "name": "rule-can-create-bind-escalate-role-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can create/update rolebindings/clusterrolebindings or bind roles/clusterroles",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# ================= create/update ===============================\n\n# fails if user has access to create/update rolebindings/clusterrolebindings\ndeny[msga] {\n     subjectVector := input[_]\n     role := subjectVector.relatedObjects[i]\n     rolebinding := subjectVector.relatedObjects[j]\n     endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n     endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n     \n     rule:= role.rules[p]\n\n     subject := rolebinding.subjects[k]\n\n\tverbs := [\"create\", \"update\", \"patch\", \"*\"]\n     verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"rbac.authorization.k8s.io\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"rolebindings\", \"clusterrolebindings\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n     msga := {\n          \"alertMessage\": sprintf(\"Subject: %v-%v can create/update rolebinding/clusterrolebinding\", [subjectVector.kind, subjectVector.name]),\n          \"alertScore\": 3,\n          \"failedPaths\": finalpath,\n          \"fixPaths\": [],\n          \"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n               \"k8sApiObjects\": [],\n               \"externalObjects\": subjectVector\n          }\n     }\n}\n\n\n# ================= bind ===============================\n\n# fails if user has access to bind clusterroles/roles\ndeny [msga] {\n     subjectVector := input[_]\n     role := subjectVector.relatedObjects[i]\n     rolebinding := subjectVector.relatedObjects[j]\n     endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n     endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n     rule:= role.rules[p]\n\n     subject := rolebinding.subjects[k]\n\n\tverbs := [\"bind\", \"*\"]\n     verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"rbac.authorization.k8s.io\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"clusterroles\", \"roles\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n\n     msga := {\n          \"alertMessage\": sprintf(\"Subject: %v-%v can bind roles/clusterroles\", [subjectVector.kind, subjectVector.name]),\n          \"alertScore\": 3,\n          \"failedPaths\":finalpath,\n          \"fixPaths\": [],\n          \"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n               \"k8sApiObjects\": [],\n               \"externalObjects\": subjectVector\n          }\n     }\n}\n\n# ================= escalate ===============================\n\n# fails if user has access to escalate rolebindings/clusterrolebindings\ndeny[msga] {\n     subjectVector := input[_]\n     role := subjectVector.relatedObjects[i]\n     rolebinding := subjectVector.relatedObjects[j]\n     endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n     endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n     rule:= role.rules[p]\n\n     subject := rolebinding.subjects[k]\n\n\tverbs := [\"escalate\", \"*\"]\n     verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"rbac.authorization.k8s.io\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"rolebindings\", \"clusterrolebindings\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n     msga := {\n          \"alertMessage\": sprintf(\"Subject: %v-%v can escalate rolebinding/clusterrolebinding\", [subjectVector.kind, subjectVector.name]),\n          \"alertScore\": 3,\n          \"failedPaths\": finalpath,\n          \"fixPaths\": [],\n          \"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n               \"k8sApiObjects\": [],\n               \"externalObjects\": subjectVector\n          }\n     }\n}"
    },
    {
        "name": "exec-into-container-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Privilege Escalation::Exec into container",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have permissions to exec into pods",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# input: regoResponseVectorObject\n# returns subjects that can exec into container\n\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"create\", \"*\"]\n    verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"pods/exec\", \"pods/*\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\t\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can exec into containers\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": finalpath,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n\t}\n}"
    },
    {
        "name": "sudo-in-container-entrypoint",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n    result := isSudoEntrypoint(container, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  have sudo in entrypoint\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result := isSudoEntrypoint(container, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in %v: %v  have sudo in entrypoint\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tresult := isSudoEntrypoint(container, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in cronjob: %v  have sudo in entrypoint\", [container.name, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": result,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nisSudoEntrypoint(container, begginingOfPath, i) = path {\n\tpath = [sprintf(\"%vcontainers[%v].command[%v]\", [begginingOfPath, format_int(i, 10), format_int(k, 10)]) |  command = container.command[k];  contains(command, \"sudo\")]\n\tcount(path) > 0\n}\n"
    },
    {
        "name": "rule-can-portforward-v1",
        "attributes": {
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"create\",  \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"pods/portforward\", \"pods/*\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can do port forwarding\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": finalpath,\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}"
    },
    {
        "name": "instance-metadata-api-access",
        "attributes": {
            "m$K8sThreatMatrix": "Credential Access::Instance Metadata API",
            "armoBuiltin": true,
            "armoOpa": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "nodes"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Checks if there is access from the nodes to cloud prividers instance metadata services",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n# Check for images from blacklisted repos\n\nmetadata_azure(z) = http.send({\n\t\"url\": \"http://169.254.169.254/metadata/instance?api-version=2020-09-01\",\n\t\"method\": \"get\",\n\t\"headers\": {\"Metadata\": \"true\"},\n\t\"raise_error\": true,\t\n})\n\nmetadata_gcp(z) = http.send({\n\t\"url\": \"http://169.254.169.254/computeMetadata/v1/?alt=json&recursive=true\",\n\t\"method\": \"get\",\n\t\"headers\": {\"Metadata-Flavor\": \"Google\"},\n\t\"raise_error\": true,\t\n})\n\nmetadata_aws(z) = metadata_object { \n\thostname := http.send({\n\t\"url\": \"http://169.254.169.254/latest/meta-data/local-hostname\",\n\t\"method\": \"get\",\n\t\"raise_error\": true,\t\n    })\n\tmetadata_object := {\n\t\t\"raw_body\": hostname.raw_body,\n\t\t\"hostname\" : hostname.raw_body,\n\t\t\"status_code\" : hostname.status_code\n\t}\n}\n\nazure_metadata[msga] {\t\n\tmetadata_object := metadata_azure(\"aaa\")\n\tmetadata_object.status_code == 200\n\tnode_name := metadata_object.body.compute.name\n\tnodes := input[_]\n\tnodes.metadata.name == node_name\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Node '%s' has access to Instance Metadata Services of Azure.\", [node_name]),\n\t\t\"alert\": true,\n\t\t\"prevent\": false,\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8SApiObjects\": [nodes],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"azureMetadata\" : [metadata_object.body]\n\t\t\t}\n\t\t}\n\t}\n}\n\ngcp_metadata[msga] {\t\n\tmetadata_object := metadata_gcp(\"aaa\")\n\tmetadata_object.status_code == 200\n\tnode_name := metadata_object.body.instance.hostname\n\tnodes := input[_]\n\tnodes.metadata.name == node_name\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Node '%s' has access to Instance Metadata Services of GCP.\", [node_name]),\n\t\t\"alert\": true,\n\t\t\"prevent\": false,\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8SApiObjects\": [nodes],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"gcpMetadata\" : [metadata_object.raw_body]\n\t\t\t}\n\t\t}\n\t}\n}\n\naws_metadata[msga] {\t\n\tmetadata_object := metadata_aws(\"aaa\")\n\tmetadata_object.status_code == 200\n\tnode_name := metadata_object.hostname\n\tnodes := input[_]\n\tnodes.metadata.name == node_name\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Node '%s' has access to Instance Metadata Services of AWS.\", [node_name]),\n\t\t\"alert\": true,\n\t\t\"prevent\": false,\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8SApiObjects\": [nodes],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"awsMetadata\" : [metadata_object.raw_body]\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "name": "rule-can-delete-logs-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Defense Evasion::Clear container logs",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can delete logs inside a container",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can delete logs of pod \ndeny [msga] {\n  subjectVector := input[_]\n  role := subjectVector.relatedObjects[i]\n  rolebinding := subjectVector.relatedObjects[j]\n  endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n  endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n  rule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"delete\", \"deletecollection\", \"*\"]\n  verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"pods/log\", \"pods/*\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n  msga := {\n    \"alertMessage\": sprintf(\"Subject: %v-%v can delete logs\", [subjectVector.kind, subjectVector.name]),\n    \"alertScore\": 3,\n    \"packagename\": \"armo_builtins\",\n    \"failedPaths\": finalpath,\n    \"fixPaths\": [],\n    \"alertObject\": {\n      \"k8sApiObjects\": [],\n      \"externalObjects\": subjectVector\n    }\n  }\n}"
    },
    {
        "name": "rule-can-create-modify-pod-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Execution::New container, Persistence::Backdoor container",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have create/modify  permissions on pods",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n# fails if subject has create/modify access to pods \ndeny [msga] {\n    subjectVector := input[_]\n    role := subjectVector.relatedObjects[i]\n    rolebinding := subjectVector.relatedObjects[j]\n    endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n    endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n    rule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"create\", \"patch\", \"update\", \"*\"]\n    verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"pods\",\"deployments\",\"daemonsets\",\"replicasets\",\"statefulsets\",\"jobs\",\"cronjobs\",\"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n\n    msga := {\n        \"alertMessage\": sprintf(\"Subject: %v-%v can create/modify workloads\", [subjectVector.kind, subjectVector.name]),\n        \"alertScore\": 3,\n        \"failedPaths\": finalpath,\n        \"fixPaths\": [],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n            \"k8sApiObjects\": [],\n            \"externalObjects\": subjectVector\n        }\n    }\n}"
    },
    {
        "name": "read-only-port-enabled",
        "attributes": {
            "armoBuiltin": true,
            "hostSensorRule": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [],
                "apiVersions": [],
                "resources": []
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "hostdata.kubescape.cloud"
                ],
                "apiVersions": [
                    "v1beta0"
                ],
                "resources": [
                    "KubeletConfiguration",
                    "KubeletCommandLine"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            },
            {
                "packageName": "kubernetes.api.client"
            }
        ],
        "description": "Determines if kubelet has read-only port enabled.",
        "remediation": "Start the kubelet with the --read-only-port flag set to 0.",
        "ruleQuery": "",
        "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\t\tnot isReadOnlyPortDisabled(kubeletConfig, kubeletCli)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"kubelet read-only port is not disabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"failedPaths\": [],\n\t\t\t\"fixPaths\": [],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n                \"k8sApiObjects\": [kubeletConfig, kubeletCli]\n\t\t\t},\n\t\t}\n\t}\n\n# 0 or not present -> disabled\nisReadOnlyPortDisabledCli(kubeletCli) {\n    kubeletCliData := kubeletCli.data\n    contains(kubeletCliData[\"fullCommand\"], \"--read-only-port=0\")\n}\n\nisReadOnlyPortDisabledCli(kubeletCli) {\n    kubeletCliData := kubeletCli.data\n    not contains(kubeletCliData[\"fullCommand\"], \"--read-only-port\")\n}\n\nisReadOnlyPortDisabledConfig(kubeletConfig) {\n    not kubeletConfig.data.readOnlyPort\n}\n\nisReadOnlyPortDisabledConfig(kubeletConfig) {\n    kubeletConfig.data.readOnlyPort == 0\n}\n\nisReadOnlyPortDisabled(kubeletConfig, kubeletCli) {\n     kubeletConfig.data.readOnlyPort == 0\n}\n\nisReadOnlyPortDisabled(kubeletConfig, kubeletCli) {\n    isReadOnlyPortDisabledCli(kubeletCli)\n    isReadOnlyPortDisabledConfig(kubeletConfig)\n    not isReadOnlyPortEnabledConfig(kubeletConfig)\n}\n\n# kubelet config takes precedence\nisReadOnlyPortEnabledConfig(kubeletConfig) {\n    kubeletConfig.data.readOnlyPort\n    kubeletConfig.data.readOnlyPort != 0\n}"
    },
    {
        "name": "host-network-access",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if pod has hostNetwork  enabled",
        "remediation": "Make sure that the hostNetwork field of the pod spec is not set to true (set to false or not present)",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# Fails if pod has hostNetwork enabled\ndeny[msga] {\n    pods := [ pod | pod = input[_] ; pod.kind == \"Pod\"]\n    pod := pods[_]\n\n\tisHostNetwork(pod.spec)\n\tpath := \"spec.hostNetwork\"\n    msga := {\n\t\"alertMessage\": sprintf(\"Pod: %v is connected to the host network\", [pod.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if workload has hostNetwork enabled\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tisHostNetwork(wl.spec.template.spec)\n\tpath := \"spec.template.spec.hostNetwork\"\n    msga := {\n\t\"alertMessage\": sprintf(\"%v: %v has a pod connected to the host network\", [wl.kind, wl.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if cronjob has hostNetwork enabled\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tisHostNetwork(wl.spec.jobTemplate.spec.template.spec)\n\tpath := \"spec.jobTemplate.spec.template.spec.hostNetwork\"\n    msga := {\n\t\"alertMessage\": sprintf(\"CronJob: %v has a pod connected to the host network\", [wl.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nisHostNetwork(podspec) {\n    podspec.hostNetwork == true\n}"
    },
    {
        "name": "rule-access-dashboard-subject-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Lateral Movement::Access Kubernetes dashboard, Discovery::Access Kubernetes dashboard",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if subject that is not dashboard service account is bound to dashboard role/clusterrole, or- if anyone that is not dashboard pod is associated with its service account.",
        "remediation": "",
        "rule": "package armo_builtins\n\n# input: regoResponseVectorObject\n# fails if a subject that is not dashboard service account is bound to dashboard role\n\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trole.metadata.name == \"kubernetes-dashboard\"\n\tsubjectVector.name != \"kubernetes-dashboard\"\n\n\tsubject := rolebinding.subjects[k]\n    path := [sprintf(\"relatedObjects[%v].subjects[%v]\", [format_int(j, 10), format_int(k, 10)])]\n\tfinalpath := array.concat(path, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v is bound to dashboard role/clusterrole\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": finalpath,\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n\t}\n}"
    },
    {
        "name": "k8s-audit-logs-enabled-native",
        "attributes": {
            "armoBuiltin": true,
            "resourcesAggregator": "apiserver-pod",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Check if audit logs is  enabled for native k8s\ndeny[msga] {\n\tapiserverpod := input[_]\n    cmd := apiserverpod.spec.containers[0].command\n\tauditPolicy :=  [ command |command := cmd[_] ; contains(command, \"--audit-policy-file=\")]\n    count(auditPolicy) < 1\n\tpath := \"spec.containers[0].command\"\t\n\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"audit logs is not enabled\",\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [apiserverpod],\n\t\t\n\t\t}\n\t}\n}"
    },
    {
        "name": "container-hostPort",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if container has hostPort",
        "remediation": "Make sure you do not configure hostPort for the container, if necessary use NodePort / ClusterIP",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if pod has container with hostPort\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    container := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n\tpath := isHostPort(container, i, begginingOfPath)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v has Host-port\", [ container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 4,\n\t\t\"failedPaths\": path,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if workload has container with hostPort\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    path := isHostPort(container, i, begginingOfPath)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   has Host-port\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 4,\n\t\t\"failedPaths\": path,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if cronjob has container with hostPort\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n    path := isHostPort(container, i, begginingOfPath)\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   has Host-port\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 4,\n\t\t\"failedPaths\": path,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\nisHostPort(container, i, begginingOfPath) = path {\n\tpath = [sprintf(\"%vcontainers[%v].ports[%v].hostPort\", [begginingOfPath, format_int(i, 10), format_int(j, 10)]) | port = container.ports[j];  port.hostPort]\n\tcount(path) > 0\n}\n"
    },
    {
        "name": "rule-deny-cronjobs",
        "attributes": {
            "m$K8sThreatMatrix": "Persistence::Kubernetes Cronjob",
            "armoBuiltin": true
        },
        "ruleLanguage": "rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "determines if it's cronjob",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# alert cronjobs\n\n#handles cronjob\ndeny[msga] {\n\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjobs are defined: %v\", [wl.metadata.name]),\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n"
    },
    {
        "name": "rule-can-ssh-to-pod",
        "attributes": {
            "microsoftK8sThreatMatrix": "Execution::SSH server running inside container",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod",
                    "Service"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "denies pods with SSH ports opened(22/222)",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: pod\n# apiversion: v1\n# does:\treturns the external facing services of that pod\n\ndeny[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tpodns := pod.metadata.namespace\n\tpodname := pod.metadata.name\n\tlabels := pod.metadata.labels\n\tfiltered_labels := json.remove(labels, [\"pod-template-hash\"])\n    path := \"metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == podns\n\tservice.spec.selector == filtered_labels\n    \n\thasSSHPorts(service)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod %v/%v exposed by SSH services: %v\", [podns, podname, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod,service]\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tlabels := wl.spec.template.metadata.labels\n    path := \"spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl,service]\n\t\t}\n     }\n}\n\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tlabels := wl.spec.jobTemplate.spec.template.metadata.labels\n    path := \"spec.jobTemplate.spec.template.metadata.labels\"\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.metadata.namespace == wl.metadata.namespace\n\tservice.spec.selector == labels\n\n\thasSSHPorts(service)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is exposed by SSH services: %v\", [wl.kind, wl.metadata.name, service]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl,service]\n\t\t}\n     }\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.port == 2222\n}\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 22\n}\n\n\nhasSSHPorts(service) {\n\tport := service.spec.ports[_]\n\tport.targetPort == 2222\n}\n"
    },
    {
        "name": "CVE-2022-0185",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Node"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\ndeny[msga] {\n\tnode := input[_]\n    node.kind == \"Node\"\n    kernelVersionMatch := regex.find_all_string_submatch_n(\"[0-9]+\\\\.[0-9]+\\\\.[0-9]+\", node.status.nodeInfo.kernelVersion, -1)\n    kernelVersion := kernelVersionMatch[0][0]\n    \n    kernelVersionArr := split(kernelVersion, \".\")\n    to_number(kernelVersionArr[0]) == 5\n    to_number(kernelVersionArr[1]) >= 1\n    to_number(kernelVersionArr[1]) <= 16\n    to_number(kernelVersionArr[2]) < 2 \n    \n    node.status.nodeInfo.operatingSystem == \"linux\"\n    path := \"status.nodeInfo.kernelVersion\"\n\n \tmsga := {\n\t\t\t\"alertMessage\": \"You are vulnerable to CVE-2022-0185\",\n    \t\t\"alertObject\": {\n               \"k8SApiObjects\": [node]\n            },\n\t\t\t\"failedPaths\": [path],\n            \"fixPaths\":[],\n\t}\n}"
    },
    {
        "name": "exec-into-container",
        "attributes": {
            "m$K8sThreatMatrix": "Privilege Escalation::Exec into container",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have permissions to exec into pods",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n# input: clusterrolebindings + rolebindings\n# apiversion: rbac.authorization.k8s.io/v1 \n# returns subjects that can exec into container\n\ndeny[msga] {\n\t roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanExecToPodResource(rule)\n\tcanExecToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"Role\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n   \tsubject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can exec into  containers\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n# input: clusterrolebindings + rolebindings\n# apiversion: rbac.authorization.k8s.io/v1 \n# returns subjects that can exec into container\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanExecToPodResource(rule)\n\tcanExecToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can exec into  containers\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n# input: clusterrolebindings + rolebindings\n# apiversion: rbac.authorization.k8s.io/v1 \n# returns subjects that can exec into container\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanExecToPodResource(rule)\n\tcanExecToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can exec into  containers\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n  \t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\ncanExecToPodVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"create\")\n}\ncanExecToPodVerb(rule)  {\n\tcautils.list_contains(rule.verbs, \"*\")\n}\n\ncanExecToPodResource(rule)  {\n\tcautils.list_contains(rule.resources, \"pods/exec\")\n\t\n}\ncanExecToPodResource(rule)  {\n\tcautils.list_contains(rule.resources, \"pods/*\")\n}\ncanExecToPodResource(rule) {\n\tisApiGroup(rule)\n\tcautils.list_contains(rule.resources, \"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}"
    },
    {
        "name": "psp-enabled-native",
        "attributes": {
            "armoBuiltin": true,
            "resourcesAggregator": "apiserver-pod",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Check if psp is enabled for native k8s\ndeny[msga] {\n\tapiserverpod := input[_]\n    cmd := apiserverpod.spec.containers[0].command[j]\n    contains(cmd, \"--enable-admission-plugins=\")\n    output := split(cmd, \"=\")\n    not contains(output[1], \"PodSecurityPolicy\")\n\tpath := sprintf(\"spec.containers[0].command[%v]\", [format_int(j, 10)])\t\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"PodSecurityPolicy is not enabled\",\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [apiserverpod],\n\t\t\n\t\t}\n\t}\n}"
    },
    {
        "name": "rule-can-impersonate-users-groups-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can impersonate users/groups",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"impersonate\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"users\", \"serviceaccounts\",\"groups\",\"uids\",\"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can impersonate users\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n    \t\"failedPaths\": finalpath,\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}"
    },
    {
        "name": "list-all-validating-webhooks",
        "attributes": {
            "m$K8sThreatMatrix": "Credential Access::Malicious admission controller",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "ValidatingWebhookConfiguration"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Returns validating webhook configurations to be verified",
        "remediation": "Analyze webhook for malicious behavior",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny [msga] {\n    admissionwebhooks := [admissionwebhook | admissionwebhook = input[_]; admissionwebhook.kind == \"ValidatingWebhookConfiguration\"]\n    admissionwebhook := admissionwebhooks[_]\n\n    \tmsga := {\n\t\t\"alertMessage\": sprintf(\"The following validating webhook configuration should be checked %v.\", [admissionwebhook.metadata.name]),\n\t\t\"alertScore\": 6,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [\"\"],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [admissionwebhook]\n\t\t}\n\t}\n}"
    },
    {
        "name": "exposed-sensitive-interfaces-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Initial access::Exposed sensitive interfaces",
            "armoBuiltin": true,
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Service",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "kubernetes.api.client"
            }
        ],
        "configInputs": [
            "settings.postureControlInputs.sensitiveInterfaces"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.sensitiveInterfaces",
                "name": "Sensitive interfaces",
                "description": "The following interfaces were seen exploited. Kubescape checks it they are externally exposed."
            }
        ],
        "description": "fails if known interfaces have exposed services",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\nimport data\n\n# loadbalancer\ndeny[msga] {\n\twl := input[_]\n\tworkload_types = {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"Pod\", \"CronJob\"}\n\tworkload_types[wl.kind]\n\n    # see default-config-inputs.json for list values\n    wl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"LoadBalancer\"\n\n\tresult := wl_connectedto_service(wl, service)\n    \n    # externalIP := service.spec.externalIPs[_]\n\texternalIP := service.status.loadBalancer.ingress[0].ip\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": wlvector\n\t\t}\n\t}\n}\n\n\n# nodePort\n# get a pod connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"Pod\"\n    \n    # see default-config-inputs.json for list values\n    wl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n    \n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n\n\tresult := wl_connectedto_service(wl, service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": wlvector\n\t\t}\n\t}\n} \n\n# nodePort\n# get a workload connected to that service, get nodeIP (hostIP?)\n# use ip + nodeport\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"CronJob\"}\n\tspec_template_spec_patterns[wl.kind]\n    \n    # see default-config-inputs.json for list values\n    wl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n    \n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\tservice.spec.type == \"NodePort\"\n\n\tresult := wl_connectedto_service(wl, service)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service: %v is exposed\", [service.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": result,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": wlvector\n\t\t}\n\t}\n}\n\n# ====================================================================================\n\nwl_connectedto_service(wl, service) = paths{\n\tcount({x | service.spec.selector[x] == wl.metadata.labels[x]}) == count(service.spec.selector)\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}\n\nwl_connectedto_service(wl, service) = paths {\n\twl.spec.selector.matchLabels == service.spec.selector\n\tpaths = [\"spec.selector.matchLabels\", \"service.spec.selector\"]\n}",
        "resourceEnumerator": "package armo_builtins\nimport data.kubernetes.api.client as client\nimport data\n\ndeny[msga] {\n\twl := input[_]\n\tworkload_types = {\"Deployment\", \"ReplicaSet\", \"DaemonSet\", \"StatefulSet\", \"Job\", \"Pod\", \"CronJob\"}\n\tworkload_types[wl.kind]\n\n\t# see default-config-inputs.json for list values\n\twl_names := data.postureControlInputs.sensitiveInterfaces\n\twl_name := wl_names[_]\n\tcontains(wl.metadata.name, wl_name)\n\n\tsrvc := get_wl_connectedto_service(wl)\n\n\twlvector = {\"name\": wl.metadata.name,\n\t\t\t\t\"namespace\": wl.metadata.namespace,\n\t\t\t\t\"kind\": wl.kind,\n\t\t\t\t\"relatedObjects\": srvc}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"wl: %v is in the cluster\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": wlvector\n\t\t}\n\t}\n}\n\nget_wl_connectedto_service(wl) = s {\n\tservice := \tinput[_]\n\tservice.kind == \"Service\"\n\twl_connectedto_service(wl, service)\n\ts = [service]\n}\n\nget_wl_connectedto_service(wl) = s {\n\tservices := [service | service = input[_]; service.kind == \"Service\"]\n\tcount({i | services[i]; wl_connectedto_service(wl, services[i])}) == 0\n\ts = []\n}\n\nwl_connectedto_service(wl, service){\n\tcount({x | service.spec.selector[x] == wl.metadata.labels[x]}) == count(service.spec.selector)\n}"
    },
    {
        "name": "validate-kubelet-tls-configuration",
        "attributes": {
            "armoBuiltin": true,
            "hostSensorRule": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [],
                "apiVersions": [],
                "resources": []
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "hostdata.kubescape.cloud"
                ],
                "apiVersions": [
                    "v1beta0"
                ],
                "resources": [
                    "KubeletConfiguration",
                    "KubeletCommandLine"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            },
            {
                "packageName": "kubernetes.api.client"
            }
        ],
        "description": "Determines if kubelet has tls configuration.",
        "remediation": "Start the kubelet with the --tls-cert-file and --tls-private-key-file flags, providing the X509 certificate and its matching private key.",
        "ruleQuery": "",
        "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\t\tkubeletCliData := kubeletCli.data\n\n\t\tisTlsDisabled(kubeletConfig, kubeletCliData)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"kubelet client TLS authentication is not enabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n                \"k8sApiObjects\": [kubeletConfig, kubeletCli]\n\t\t\t},\n\t\t}\n\t}\n\n# CLI overrides config\nisTlsDisabled(kubeletConfig, kubeletCli) {\n    isNotTlsCli(kubeletCli)\n    isNotTlsConfig(kubeletConfig)\n}\n\nisNotTlsCli(kubeletCliData) {\n\tnot contains(kubeletCliData[\"fullCommand\"], \"tls-cert-file\")\n\tnot contains(kubeletCliData[\"fullCommand\"], \"tls-private-key-file\")\n}\n\nisNotTlsConfig(kubeletConfig){\n    not kubeletConfig.data.tlsCertFile\n    not kubeletConfig.data.tlsPrivateKeyFile\n}"
    },
    {
        "name": "pod-specific-version-tag",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Fails if container has image tag set to latest",
        "remediation": "Make sure you define a specific image tag for container and not 'latest'.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    container := pod.spec.containers[i]\n    isLatestImageTag(container)\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in pod: %v has latest image tag.\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    isLatestImageTag(container)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v  has latest image tag.\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    isLatestImageTag(container)\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v has latest image tag.\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\nisLatestImageTag(container) {\n    endswith(container.image, \":latest\")\n}"
    },
    {
        "name": "rule-can-update-configmap",
        "attributes": {
            "microsoftK8sThreatMatrix": "Lateral Movement::CoreDNS poisoning",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding",
                    "ConfigMap"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can update/patch the 'coredns' configmap",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n\n# Fails if user can modify all configmaps, or if he can modify the 'coredns' configmap (default for coredns)\n#RoleBinding to Role\ndeny [msga] {\n     configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n     configmap := configmaps[_]\n     configmap.metadata.name == \"coredns\"\n\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\n    canModifyConfigMapResource(rule)\n    canModifyConfigMapVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n    rolebinding.metadata.namespace == \"kube-system\"\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can modify 'coredns' configmap\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n# Fails if user can modify all configmaps, or if he can modify the 'coredns' configmap (default for coredns)\n# RoleBinding to ClusterRole\ndeny[msga] {\n     configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n     configmap := configmaps[_]\n     configmap.metadata.name == \"coredns\"\n\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canModifyConfigMapResource(rule)\n    canModifyConfigMapVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n    rolebinding.metadata.namespace == \"kube-system\"\n\n\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can modify 'coredns' configmap\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n\n}\n\n\n# Fails if user can modify all configmaps, or if he can modify the 'coredns' configmap (default for coredns)\n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n     configmap := configmaps[_]\n     configmap.metadata.name == \"coredns\"\n\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canModifyConfigMapResource(rule)\n    canModifyConfigMapVerb(rule)\n\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    \tmsga := {\n\t     \"alertMessage\": sprintf(\"The following %v: %v can modify 'coredns'  configmap\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 6,\n          \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n\n\n\n  canModifyConfigMapResource(rule) {\n        not rule.resourceNames\n       cautils.list_contains(rule.resources,\"configmaps\")\n  }\n\n  canModifyConfigMapResource(rule) {\n       not rule.resourceNames\n       isApiGroup(rule)\n       cautils.list_contains(rule.resources,\"*\")\n  }\n\n   canModifyConfigMapResource(rule) {\n       cautils.list_contains(rule.resources,\"configmaps\")\n       cautils.list_contains(rule.resourceNames,\"coredns\")\n   }\n\n   canModifyConfigMapVerb(rule) {\n       cautils.list_contains(rule.verbs,\"update\")\n   }\n\n\n   canModifyConfigMapVerb(rule) {\n       cautils.list_contains(rule.verbs,\"patch\")\n   }\n\n      canModifyConfigMapVerb(rule) {\n       cautils.list_contains(rule.verbs,\"*\")\n   }\n\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}"
    },
    {
        "name": "user-id-less-than-thousands",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if container can run as high user (id less than 1000)",
        "remediation": "Make sure that the user/group in the securityContext of pod/container is set to an id less than 1000.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# TODO - FIX FAILED PATHS IF THE CONTROL WILL BE ACTIVE AGAIN\n\n# Fails if pod has container  configured to run with id less than 1000\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n    result := isRootContainer(container, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  runs with id less than 1000\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [result],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if pod has container  configured to run with id less than 1000\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"\"\n    result := isRootPod(pod, container, begginingOfPath)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  runs with id less than 1000\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [result],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n\n\n# Fails if workload has container configured to run with id less than 1000\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result := isRootContainer(container, begginingOfPath, i)\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v runs with id less than 1000\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [result],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if workload has container configured to run with id less than 1000\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.\"\n    result := isRootPod(wl.spec.template, container, begginingOfPath)\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v runs with id less than 1000\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [result],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n# Fails if cronjob has a container configured to run with id less than 1000\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tresult := isRootContainer(container, begginingOfPath, i)\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v  runs with id less than 1000\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [result],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\n# Fails if workload has container configured to run with id less than 1000\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.\"\n    result := isRootPod(wl.spec.jobTemplate.spec.template, container, begginingOfPath)\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v runs with id less than 1000\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [result],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\nisRootPod(pod, container, begginingOfPath) = path {\n\tnot container.securityContext.runAsGroup\n    not container.securityContext.runAsUser\n    pod.spec.securityContext.runAsUser < 1000\n\tnot pod.spec.securityContext.runAsGroup\n\tpath = sprintf(\"%vspec.securityContext.runAsUser\", [begginingOfPath])\n}\n\nisRootPod(pod, container, begginingOfPath) = path {\n\tnot container.securityContext.runAsUser\n    not container.securityContext.runAsGroup\n    pod.spec.securityContext.runAsGroup < 1000\n\tnot pod.spec.securityContext.runAsUser\n\tpath = sprintf(\"%vspec.securityContext.runAsGroup\", [begginingOfPath])\n}\n\nisRootPod(pod, container, begginingOfPath) = path {\n    pod.spec.securityContext.runAsGroup > 1000\n\t pod.spec.securityContext.runAsUser < 1000\n\tpath = sprintf(\"%vspec.securityContext.runAsUser\", [begginingOfPath])\n}\n\nisRootPod(pod, container, begginingOfPath) = path {\n    pod.spec.securityContext.runAsGroup < 1000\n\tpod.spec.securityContext.runAsUser > 1000\n\tpath = sprintf(\"%vspec.securityContext.runAsGroup\", [begginingOfPath])\n}\n\nisRootPod(pod, container, begginingOfPath) = path {\n    pod.spec.securityContext.runAsGroup < 1000\n\t pod.spec.securityContext.runAsUser < 1000\n\tpath = sprintf(\"%vspec.securityContext\", [begginingOfPath])\n}\n\n\nisRootContainer(container, begginingOfPath, i) = path {\n    container.securityContext.runAsUser < 1000\n\tnot container.securityContext.runAsGroup\n\tpath = sprintf(\"%vcontainers[%v].securityContext.runAsUser\", [begginingOfPath, format_int(i, 10)])\n}\n\nisRootContainer(container, begginingOfPath, i) = path {\n    container.securityContext.runAsGroup < 1000\n\tnot container.securityContext.runAsUser\n\tpath = sprintf(\"%vcontainers[%v].securityContext.runAsGroup\", [begginingOfPath, format_int(i, 10)])\n}"
    },
    {
        "name": "immutable-container-filesystem",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if container has mutable filesystem",
        "remediation": "Make sure that the securityContext.readOnlyRootFilesystem field in the container/pod spec is set to true",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if pods has container with mutable filesystem\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n    result := isMutableFilesystem(container, begginingOfPath, i)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  has  mutable filesystem\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if workload has  container with mutable filesystem \ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result := isMutableFilesystem(container, begginingOfPath, i)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v has  mutable filesystem\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n# Fails if cronjob has  container with mutable filesystem \ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n\tresult := isMutableFilesystem(container, begginingOfPath, i)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v has mutable filesystem\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Default of readOnlyRootFilesystem is false. This field is only in container spec and not pod spec\nisMutableFilesystem(container, begginingOfPath, i) = [failedPath, fixPath]  {\n\tcontainer.securityContext.readOnlyRootFilesystem == false\n\tfailedPath = sprintf(\"%vcontainers[%v].securityContext.readOnlyRootFilesystem\", [begginingOfPath, format_int(i, 10)])\n\tfixPath = \"\"\n }\n\n isMutableFilesystem(container, begginingOfPath, i)  = [failedPath, fixPath] {\n\tnot container.securityContext.readOnlyRootFilesystem == false\n    not container.securityContext.readOnlyRootFilesystem == true\n\tfixPath = {\"path\": sprintf(\"%vcontainers[%v].securityContext.readOnlyRootFilesystem\", [begginingOfPath, format_int(i, 10)]), \"value\": \"true\"}\n\tfailedPath = \"\"\n }\n\n\n getFailedPath(paths) = [paths[0]] {\n\tpaths[0] != \"\"\n} else = []\n\n\ngetFixedPath(paths) = [paths[1]] {\n\tpaths[1] != \"\"\n} else = []\n"
    },
    {
        "name": "more-than-one-replicas",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "StatefulSet"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Replicas are set to one.",
        "remediation": "Ensure replicas field is set and value is bigger than one.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if workload  has only one replica\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"StatefulSet\"}\n\tspec_template_spec_patterns[wl.kind]\n    spec := wl.spec\n    result := replicasOneOrLess(spec)\n\tfailedPath := getFailedPath(result)\n    fixedPath := getFixedPath(result)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Workload: %v: %v has only one replica\", [ wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n\t\t\"fixPaths\": fixedPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\nreplicasOneOrLess(spec) =  [failedPath, fixPath] {\n\tnot spec.replicas\n\tfailedPath = \"\"\n\tfixPath = {\"path\": \"spec.replicas\", \"value\": \"YOUR_VALUE\"}\n}\n\nreplicasOneOrLess(spec) =  [failedPath, fixPath] {\n\tspec.replicas == 1\n\tfailedPath = \"spec.replicas\"\n\tfixPath = \"\"\n}\n\n getFailedPath(paths) = [paths[0]] {\n\tpaths[0] != \"\"\n} else = []\n\n\ngetFixedPath(paths) = [paths[1]] {\n\tpaths[1] != \"\"\n} else = []\n\n"
    },
    {
        "name": "rule-can-delete-k8s-events-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Defense Evasion::Delete K8S events",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can delete events",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can delete events\ndeny [msga] {\n    subjectVector := input[_]\n    role := subjectVector.relatedObjects[i]\n    rolebinding := subjectVector.relatedObjects[j]\n    endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n    endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n    rule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"delete\", \"deletecollection\", \"*\"]\n    verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"events\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n\t\n\n    msga := {\n        \"alertMessage\": sprintf(\"Subject: %v-%v can delete events\", [subjectVector.kind, subjectVector.name]),\n        \"alertScore\": 3,\n        \"packagename\": \"armo_builtins\",\n        \"failedPaths\": finalpath,\n        \"fixPaths\": [],\n        \"alertObject\": {\n            \"k8sApiObjects\": [],\n            \"externalObjects\": subjectVector\n        }\n    }\n}\n"
    },
    {
        "name": "nginx-ingress-snippet-annotation-vulnerability",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ConfigMap"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\ndeny[msga] {\n\tdeployment := input[_]\n\tdeployment.kind == \"Deployment\"\n\timage := deployment.spec.template.spec.containers[i].image\n\tisNginxImage(image)\n\tisTagImage(image)\n\tisVulnerable(image, deployment.metadata.namespace)\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25742. Deployment %v\", [deployment.metadata.name]),\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"fixPaths\":[],\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [deployment]},\n\t\t}\n}\n\n\t\nisNginxImage(image) {\n\tcontains(image, \"nginx-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-nginx\")\n}\n\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag <= \"v0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag  == \"v1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag <= \"v0.49\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag  == \"v1.0.0\"\n}\n\n###### without 'v'\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag <= \"0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag <= \"0.49\"\n}\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n    configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n\tconfigmapOnIngressNamespace := [configmap |  configmap= configmaps[_]; configmap.metadata.namespace == namespace]\n\tconfigMapsWithSnippet := [configmap |  configmap= configmapOnIngressNamespace[_];  configmap.data[\"allow-snippet-annotations\"] == \"false\"]\n\tcount(configMapsWithSnippet) < 1\n}\n\n\nisTagImage(image) {\n    reg := \":[\\\\w][\\\\w.-]{0,127}(\\/)?\"\n    version := regex.find_all_string_submatch_n(reg, image, -1)\n    v := version[_]\n    img := v[_]\n    not endswith(img, \"/\")\n}",
        "resourceEnumerator": "package armo_builtins\n\ndeny[msga] {\n\tdeployment := input[_]\n\tdeployment.kind == \"Deployment\"\n\timage := deployment.spec.template.spec.containers[i].image\n\tisNginxImage(image)\n\tisTagImage(image)\n\tisVulnerable(image, deployment.metadata.namespace)\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25742. %v\", [deployment]),\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [deployment]},\n\t\t}\n}\n\n\t\nisNginxImage(image) {\n\tcontains(image, \"nginx-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-controller\")\n}\n\nisNginxImage(image) {\n\tcontains(image, \"ingress-nginx\")\n}\n\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag <= \"v0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    startswith(tag, \"v\")\n    tag  == \"v1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag <= \"v0.49\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    startswith(tag, \"v\")\n\ttag  == \"v1.0.0\"\n}\n\n###### without 'v'\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag <= \"0.49\"\n}\n\t\nisVulnerable(image, namespace) {\n\tcontains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := split(version[count(version)-2], \"@\")[0]\n    not startswith(tag, \"v\")\n    tag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag <= \"0.49\"\n}\nisVulnerable(image, namespace) {\n\tnot contains(image, \"@\")\n\tversion := split(image, \":\")\n\ttag := version[count(version)-1]\n    not startswith(tag, \"v\")\n\ttag  == \"1.0.0\"\n}\n\nisVulnerable(image, namespace) {\n    configmaps := [configmap | configmap = input[_]; configmap.kind == \"ConfigMap\"]\n\tconfigmapOnIngressNamespace := [configmap |  configmap= configmaps[_]; configmap.metadata.namespace == namespace]\n\tconfigMapsWithSnippet := [configmap |  configmap= configmapOnIngressNamespace[_];  configmap.data[\"allow-snippet-annotations\"] == \"false\"]\n\tcount(configMapsWithSnippet) < 1\n}\n\n\nisTagImage(image) {\n    reg := \":[\\\\w][\\\\w.-]{0,127}(\\/)?\"\n    version := regex.find_all_string_submatch_n(reg, image, -1)\n    v := version[_]\n    img := v[_]\n    not endswith(img, \"/\")\n}"
    },
    {
        "name": "rule-can-create-pod-kube-system",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can create pods in kube-system namespace",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n# fails if user has create access to pods within kube-system namespace\n# RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateToPodNamespace(role)\n    canCreateToPodResource(rule)\n    canCreateToPodVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can create pods in kube-system\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n\n\n# fails if user has create access to pods within kube-system namespace\n# RoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateToPodNamespace(rolebinding)\n    canCreateToPodResource(rule)\n    canCreateToPodVerb(rule)\n\n\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n    \t\"alertMessage\": sprintf(\"The following %v: %v can create pods in kube-system\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\n\n\n# fails if user has create access to pods within kube-system namespace\n# ClusterRoleBinding to ClusterRole\ndeny [msga]{\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n     clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n     clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canCreateToPodResource(rule)\n    canCreateToPodVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can create pods in kube-system\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 3,\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n\ncanCreateToPodResource(rule){\n    cautils.list_contains(rule.resources,\"pods\")\n}\n\ncanCreateToPodResource(rule){\n    isApiGroup(rule)\n    cautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\ncanCreateToPodVerb(rule) {\n    cautils.list_contains(rule.verbs, \"create\")\n}\n\n\ncanCreateToPodVerb(rule) {\n    cautils.list_contains(rule.verbs, \"*\")\n}\n\ncanCreateToPodNamespace(role) {\n        role.metadata.namespace == \"kube-system\"\n}\n"
    },
    {
        "name": "image-pull-policy-is-not-set-to-always",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pods",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "check imagePullPolicy filed, if imagePullPolicy = always pass, else fail.",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n    isBadContainer(container)\n\tpaths = [sprintf(\"spec.containers[%v].image\", [format_int(i, 10)]), sprintf(\"spec.containers[%v].imagePullPolicy\", [format_int(i, 10)])]\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  has 'latest' tag on image but imagePullPolicy is not set to 'Always'\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": paths,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\tpaths = [sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)]), sprintf(\"spec.template.spec.containers[%v].imagePullPolicy\", [format_int(i, 10)])]\n    isBadContainer(container)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in %v: %v  has 'latest' tag on image but imagePullPolicy is not set to 'Always'\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": paths,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tpaths = [sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)]), sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].imagePullPolicy\", [format_int(i, 10)])]\n    isBadContainer(container)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in cronjob: %v  has 'latest' tag on image but imagePullPolicy is not set to 'Always'\", [container.name, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": paths,\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# image tag is latest\nisBadContainer(container){\n    reg := \":[\\\\w][\\\\w.-]{0,127}(\\/)?\"\n    version := regex.find_all_string_submatch_n(reg, container.image, -1)\n    v := version[_]\n    img := v[_]\n    img == \":latest\"\n    notImagePullPolicy(container)\n}\n\n# No image tag or digest (== latest)\nisBadContainer(container){\n    not isTagImage(container.image)\n    notImagePullPolicy(container)\n}\n\n# image tag is only letters (== latest)\nisBadContainer(container){\n    isTagImageOnlyLetters(container.image)\n    notImagePullPolicy(container)\n}\n\nnotImagePullPolicy(container) {\n     container.imagePullPolicy == \"Never\"\n}\n\n\nnotImagePullPolicy(container) {\n     container.imagePullPolicy == \"IfNotPresent\"\n}\n\nisTagImage(image) {\n    reg := \":[\\\\w][\\\\w.-]{0,127}(\\/)?\"\n    version := regex.find_all_string_submatch_n(reg, image, -1)\n    v := version[_]\n    img := v[_]\n    not endswith(img, \"/\")\n}\n\n# The image has a tag, and contains only letters\nisTagImageOnlyLetters(image) {\n    reg := \":[\\\\w][\\\\w.-]{0,127}(\\/)?\"\n    version := regex.find_all_string_submatch_n(reg, image, -1)\n    v := version[_]\n    img := v[_]\n\treg1 := \"^:[a-zA-Z]{1,127}$\"\n\tre_match(reg1, img)\n}\n"
    },
    {
        "name": "rule-name-similarity",
        "attributes": {
            "m$K8sThreatMatrix": "Defense evasion::Pod / container name similarity",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pod",
                    "ReplicaSet",
                    "Job"
                ]
            }
        ],
        "ruleDependencies": [],
        "configInputs": [
            "settings.postureControlInputs.wlKnownNames"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.wlKnownNames",
                "name": "Kubescape will look for the following deployment names in your cluster, it will make sure that no one is trying to create similar pod names to hide their attack. ",
                "description": "Deployment names"
            }
        ],
        "description": "fails if there are objects with names similar to system pods, or other known deployments",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data\n# import data.cautils as cautils\n# import data.kubernetes.api.client as client\n\n# input: pods\n# apiversion: v1\n# fails if object has similar name to known workload (but is not from that workload)\n\ndeny[msga] {\n\tobject := input[_]\n\twanted_kinds := {\"Pod\", \"ReplicaSet\", \"Job\"}\n\twanted_kinds[object.kind]\n\n\t# see default-config-inputs.json for list values\n    wl_known_names := data.postureControlInputs.wlKnownNames\n    wl_name := wl_known_names[_]\n    contains(object.metadata.name, wl_name)\n\tpath := \"metadata.name\"\n\t\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"this %v has a similar name to %v\", [object.kind, wl_name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [object]\n\t\t}\n     }\n}"
    },
    {
        "name": "anonymous-requests-to-kubelet-service",
        "attributes": {
            "armoBuiltin": true,
            "hostSensorRule": "true"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [],
                "apiVersions": [],
                "resources": []
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "hostdata.kubescape.cloud"
                ],
                "apiVersions": [
                    "v1beta0"
                ],
                "resources": [
                    "KubeletConfiguration",
                    "KubeletCommandLine"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            },
            {
                "packageName": "kubernetes.api.client"
            }
        ],
        "description": "Determines if anonymous requests are to kubelet service are allowed.",
        "remediation": "Disable anonymous requests by setting  the anonymous-auth flag to false, or using the kubelet configuration file.",
        "ruleQuery": "",
        "rule": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\t\t\n\n\t\texternalObj := isAnonymouRequestsDisabled(kubeletConfig, kubeletCli)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"anonymous requests is enabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"failedPaths\": [],\n\t\t\t\"fixPaths\":[],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"externalObjects\": externalObj\n\t\t\t}\n\t\t}\n\t}\n\n# CLI overrides config\nisAnonymouRequestsDisabled(kubeletConfig, kubeletCli) = obj {\n\tkubeletCliData := kubeletCli.data\n\tcontains(kubeletCliData[\"fullCommand\"], \"anonymous-auth=true\")\n    obj := kubeletCli\n}\n\nisAnonymouRequestsDisabled(kubeletConfig, kubeletCli) = obj {\n\tkubeletConfig.data.authentication.anonymous.enabled == true\n\tkubeletCliData := kubeletCli.data\n\tnot contains(kubeletCliData[\"fullCommand\"], \"anonymous-auth=false\")\n    not contains(kubeletCliData[\"fullCommand\"], \"anonymous-auth=true\")\n    obj := kubeletConfig\n}",
        "resourceEnumerator": "package armo_builtins\nimport data.kubernetes.api.client as client\n\ndeny[msga] {\n\t\tkubeletConfig := input[_]\n\t\tkubeletConfig.kind == \"KubeletConfiguration\"\n\t\tkubeletConfig.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\tkubeletCli := input[_]            \n\t\tkubeletCli.kind == \"KubeletCommandLine\"\n\t\tkubeletCli.apiVersion == \"hostdata.kubescape.cloud/v1beta0\"\n\n\t\texternalObj := getObj(kubeletConfig, kubeletCli)\n\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": \"anonymous requests is enabled\",\n\t\t\t\"alertScore\": 2,\n\t\t\t\"failedPaths\": [],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"externalObjects\": externalObj\n\t\t\t}\n\t\t}\n\t}\n\ngetObj(kubeletConfig, kubeletCli) = obj {\n\tkubeletCli.data[\"anonymous-auth\"] == false\n    obj := kubeletCli\n}\n\ngetObj(kubeletConfig, kubeletCli) = obj {\n\tkubeletCli.data[\"anonymous-auth\"] == true\n    obj := kubeletCli\n}\n\ngetObj(kubeletConfig, kubeletCli) = obj {\n\tnot kubeletCli.data[\"anonymous-auth\"] == true\n    not kubeletCli.data[\"anonymous-auth\"] == false\n    obj := kubeletConfig\n}"
    },
    {
        "name": "rule-can-delete-create-service-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have create/delete  permissions on services",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user has create/delete access to services\ndeny[msga] {\n    subjectVector := input[_]\n    role := subjectVector.relatedObjects[i]\n    rolebinding := subjectVector.relatedObjects[j]\n    endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n    endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n    rule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"create\", \"delete\",  \"deletecollection\", \"*\"]\n    verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"services\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    \tmsga := {\n          \"alertMessage\": sprintf(\"Subject: %v-%v can create/delete services\", [subjectVector.kind, subjectVector.name]),\n          \"alertScore\": 3,\n          \"failedPaths\": finalpath,\n          \"fixPaths\": [],\n          \"packagename\": \"armo_builtins\",\n          \"alertObject\": {\n               \"k8sApiObjects\": [],\n               \"externalObjects\": subjectVector\n          }\n     }\n}"
    },
    {
        "name": "rule-list-all-cluster-admins-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Privilege Escalation::Cluster-admin binding",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users have cluster admin permissions",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# returns subjects with cluster admin permissions\ndeny[msga] {\n\tsubjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"*\", \"\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v have high privileges, such as cluster-admin\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": finalpath,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}\n"
    },
    {
        "name": "rule-can-impersonate-users-groups",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can impersonate users/groups",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n\ndeny[msga] {\n\t roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanImpersonateVerb(rule)\n    canImpersonateResource(rule)\n\n\trolebinding.roleRef.kind == \"Role\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can impersonate users\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanImpersonateVerb(rule)\n    canImpersonateResource(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v,  can impersonate users\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanImpersonateVerb(rule)\n    canImpersonateResource(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can impersonate users\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n  \t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ncanImpersonateVerb(rule) {\n\t\tcautils.list_contains(rule.verbs, \"impersonate\")\n}\ncanImpersonateVerb(rule) {\n\t\tcautils.list_contains(rule.verbs, \"*\")\n}\n\n\ncanImpersonateResource(rule) {\n\tcautils.list_contains(rule.resources,\"users\")\n}\n\ncanImpersonateResource(rule) {\n\tcautils.list_contains(rule.resources,\"serviceaccounts\")\n}\n\ncanImpersonateResource(rule) {\n\tcautils.list_contains(rule.resources,\"groups\")\n}\n\ncanImpersonateResource(rule) {\n\tcautils.list_contains(rule.resources,\"uids\")\n}\n\ncanImpersonateResource(rule) {\n\tisApiGroup(rule)\n\tcautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}"
    },
    {
        "name": "rule-can-list-get-secrets-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can list/get secrets",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user can list/get secrets \ndeny[msga] {\n    subjectVector := input[_]\n\trole := subjectVector.relatedObjects[i]\n\trolebinding := subjectVector.relatedObjects[j]\n\tendswith(subjectVector.relatedObjects[i].kind, \"Role\")\n\tendswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\trule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"get\", \"list\", \"watch\", \"*\"]\n  \tverbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"secrets\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Subject: %v-%v can read secrets\", [subjectVector.kind, subjectVector.name]),\n\t\t\"alertScore\": 3,\n\t\t\"failedPaths\": finalpath,\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": subjectVector\n\t\t}\n  \t}\n}"
    },
    {
        "name": "CVE-2022-24348",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "a",
        "remediation": "a",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\ndeny[msga] {\n\tdeployment := input[_]\n\tdeployment.kind == \"Deployment\"\n\timage := deployment.spec.template.spec.containers[i].image\n\tcontains(image, \"argocd:v\")\n\tisVulnerableImage(image)\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    msga := {\n\t\t\t\"alertMessage\": \"You may be vulnerable to CVE-2022-24348\",\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"fixPaths\":[],\n\t\t\t\"alertObject\": { \n                \"k8SApiObjects\": [deployment]\n            },\n\t\t}\n}\n\nisVulnerableImage(image) {\n\tversion := split(image, \":v\")[1]\n\tversionTriplet := split(version, \".\")\n\tcount(versionTriplet) == 3\n\tmajorVersion := to_number(versionTriplet[0])\n\tminorVersion := to_number(versionTriplet[1])\n\tsubVersion := to_number(versionTriplet[2])  \n\tisVulnerableVersion(majorVersion,minorVersion,subVersion)\n}\n\nisVulnerableVersion(majorVersion, minorVersion, subVersion) {\n\tmajorVersion == 1\n} \n\nisVulnerableVersion(majorVersion, minorVersion, subVersion) {\n\tmajorVersion == 2\n\tminorVersion == 0\n}\n\nisVulnerableVersion(majorVersion, minorVersion, subVersion) {\n\tmajorVersion == 2\n\tminorVersion == 1\n\tsubVersion < 9\n}\n\nisVulnerableVersion(majorVersion, minorVersion, subVersion) {\n\tmajorVersion == 2\n\tminorVersion == 2\n\tsubVersion < 4\n}\t\n\n",
        "resourceEnumerator": "package armo_builtins\n\ndeny[msga] {\n\tdeployment := input[_]\n\tdeployment.kind == \"Deployment\"\n\timage := deployment.spec.template.spec.containers[i].image\n\tcontains(image, \"argocd:v\")\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n    msga := {\n\t\t\t\"alertMessage\": \"You may be vulnerable to CVE-2022-24348\",\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"alertObject\": { \n                \"k8SApiObjects\": [deployment]\n            },\n\t\t}\n}\n"
    },
    {
        "name": "host-pid-ipc-privileges",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Containers should be as isolated as possible from the host machine. The hostPID and hostIPC fields in Kubernetes may excessively expose the host to potentially malicious actions.",
        "remediation": "Make sure that the fields hostIPC and hostPID in the pod spec are not set to true (set to false or not present)",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if pod has hostPID enabled\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tisHostPID(pod.spec)\n\tpath := \"spec.hostPID\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has hostPID enabled\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if pod has hostIPC enabled\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tisHostIPC(pod.spec)\n\tpath := \"spec.hostIPC\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v has hostIPC enabled\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n\n# Fails if workload has hostPID enabled\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tisHostPID(wl.spec.template.spec)\n\tpath := \"spec.template.spec.hostPID\"\n    msga := {\n\t\"alertMessage\": sprintf(\"%v: %v has a pod with hostPID enabled\", [wl.kind, wl.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n# Fails if workload has hostIPC enabled\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tisHostIPC(wl.spec.template.spec)\n\tpath := \"spec.template.spec.hostIPC\"\n    msga := {\n\t\"alertMessage\": sprintf(\"%v: %v has a pod with hostIPC enabled\", [wl.kind, wl.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if cronjob has hostPID enabled\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tisHostPID(wl.spec.jobTemplate.spec.template.spec)\n\tpath := \"spec.jobTemplate.spec.template.spec.hostPID\"\n    msga := {\n\t\"alertMessage\": sprintf(\"CronJob: %v has a pod with hostPID enabled\", [wl.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n# Fails if cronjob has hostIPC enabled\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tisHostIPC(wl.spec.jobTemplate.spec.template.spec)\n\tpath := \"spec.jobTemplate.spec.template.spec.hostIPC\"\n    msga := {\n\t\"alertMessage\": sprintf(\"CronJob: %v has a pod with hostIPC enabled\", [wl.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Check that hostPID and hostIPC are set to false. Default is false. Only in pod spec\n\n\nisHostPID(podspec){\n    podspec.hostPID == true\n}\n\nisHostIPC(podspec){\n     podspec.hostIPC == true\n}"
    },
    {
        "name": "K8s common labels usage",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pods",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.k8sRecommendedLabels",
                "name": "Kubernetes Recommended Labels",
                "description": "Kubescape checks that workloads have at least one of the following kubernetes recommended labels."
            }
        ],
        "description": "Check if the list of label that start with app.kubernetes.io/ are defined.",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n# Deny mutating action unless user is in group owning the resource\n\n\n\ndeny[msga] {\n\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tfixPath := noK8sLabelOrNoK8sLabelUsage(pod, \"\")\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"in the following pod the kubernetes common labels are not defined: %v\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPath,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n     }\n}\n\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tpodSpec := wl.spec.template\n\tbegginingOfPodPath := \"spec.template.\"\n\tfixPath := noK8sLabelUsage(wl, podSpec, begginingOfPodPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v the kubernetes common labels are is not defined:\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPath,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n#handles cronjob\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tpodSpec := wl.spec.jobTemplate.spec.template\n\tbegginingOfPodPath := \"spec.jobTemplate.spec.template.\"\n\tfixPath := noK8sLabelUsage(wl, podSpec, begginingOfPodPath)\n\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjobs the kubernetes common labels are not defined: %v\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 1,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPath,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n\n\n# There is no label-usage in WL and also for his Pod\nnoK8sLabelUsage(wl, podSpec, begginingOfPodPath) = path{\n\tpath1 := noK8sLabelOrNoK8sLabelUsage(wl, \"\")\n\tpath2 := noK8sLabelOrNoK8sLabelUsage(podSpec, begginingOfPodPath)\n\tpath = array.concat(path1, path2)\n}\n\n# There is label-usage for WL but not for his Pod\nnoK8sLabelUsage(wl, podSpec, begginingOfPodPath) = path{\n\tnot noK8sLabelOrNoK8sLabelUsage(wl, \"\")\n\tpath := noK8sLabelOrNoK8sLabelUsage(podSpec, begginingOfPodPath)\n}\n\n# There is no label-usage for WL but there is for his Pod\nnoK8sLabelUsage(wl, podSpec, begginingOfPodPath) = path{\n\tnot noK8sLabelOrNoK8sLabelUsage(podSpec, begginingOfPodPath)\n\tpath := noK8sLabelOrNoK8sLabelUsage(wl, \"\")\n}\n\nnoK8sLabelOrNoK8sLabelUsage(wl, begginingOfPath) = path{\n\tnot wl.metadata.labels\n\tpath = [{\"path\": sprintf(\"%vmetadata.labels\", [begginingOfPath]), \"value\": \"YOUR_VALUE\"}]\n}\n\nnoK8sLabelOrNoK8sLabelUsage(wl, begginingOfPath) = path{\n\tmetadata := wl.metadata\n\tnot metadata.labels\n\tpath = [{\"path\": sprintf(\"%vmetadata.labels\", [begginingOfPath]), \"value\": \"YOUR_VALUE\"}]\n}\n\nnoK8sLabelOrNoK8sLabelUsage(wl, begginingOfPath) = path{\n\tlabels := wl.metadata.labels\n\tnot allKubernetesLabels(labels)\n\tpath = [{\"path\": sprintf(\"%vmetadata.labels\", [begginingOfPath]), \"value\": \"YOUR_VALUE\"}]\n}\n\nallKubernetesLabels(labels){\n\trecommended_labels := data.postureControlInputs.k8sRecommendedLabels\n\trecommended_label := recommended_labels[_]\n\tlabels[recommended_label]\n}\n"
    },
    {
        "name": "rule-can-portforward",
        "attributes": {
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "\npackage armo_builtins\nimport data.cautils as cautils\n\n\ndeny[msga] {\n\t roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanForwardToPodResource(rule)\n\tcanForwardToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"Role\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can do port forwarding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanForwardToPodResource(rule)\n\tcanForwardToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can do port forwarding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n\tcanForwardToPodResource(rule)\n\tcanForwardToPodVerb(rule)\n\n\trolebinding.roleRef.kind == \"ClusterRole\"\n\trolebinding.roleRef.name == role.metadata.name\n\t\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following %v: %v, can do port forwarding\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n  \t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role, rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\ncanForwardToPodVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"create\")\n}\n\ncanForwardToPodVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"get\")\n}\ncanForwardToPodVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"*\")\n}\n\ncanForwardToPodResource(rule) {\n\tcautils.list_contains(rule.resources,\"pods/portforward\")\n}\ncanForwardToPodResource(rule) {\n\tcautils.list_contains(rule.resources,\"pods/*\")\n}\ncanForwardToPodResource(rule) {\n\tisApiGroup(rule)\n\tcautils.list_contains(rule.resources,\"*\")\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\n"
    },
    {
        "name": "linux-hardening",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if container does not defien any linux security hardening",
        "remediation": "Make sure you define  at least one linux security hardening property out of Seccomp, SELinux or Capabilities.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# TODO: Decide fixPath\n\n# Fails if pod does not define linux security hardening \ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    isUnsafePod(pod)\n    container := pod.spec.containers[_]\n    isUnsafeContainer(container)\n \n\tbegginingOfPath := \"spec\"\n\tpath := getPath(pod.spec, begginingOfPath)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Pod: %v does not define any linux security hardening\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if workload does not define linux security hardening \ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    isUnsafeWorkload(wl)\n    container := wl.spec.template.spec.containers[_]\n    isUnsafeContainer(container)\n\n\tbegginingOfPath := \"spec.template.spec\"\n\tpath := getPath(wl.spec.template.spec, begginingOfPath)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Workload: %v does not define any linux security hardening\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n# Fails if pod does not define linux security hardening \ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    isUnsafeCronJob(wl)\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[_]\n    isUnsafeContainer(container)\n\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec\"\n\tpath := getPath(wl.spec.jobTemplate.spec.template.spec, begginingOfPath)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Cronjob: %v does not define any linux security hardening\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\ngetPath(podSpec, begginingOfPath) = path {\n\tpodSpec.securityContext\n\tpath := sprintf(\"%v.securityContext\", [begginingOfPath])\n}\n\ngetPath(podSpec, begginingOfPath) = path {\n\tnot podSpec.securityContext\n\tpath := begginingOfPath\n}\n\nisUnsafePod(pod){\n    not pod.spec.securityContext.seccompProfile\n    not pod.spec.securityContext.seLinuxOptions\n\tannotations := [pod.metadata.annotations[i] | annotaion = i; startswith(i, \"container.apparmor.security.beta.kubernetes.io\")]\n\tnot count(annotations) > 0\n}\n\nisUnsafeContainer(container){\n    not container.securityContext.seccompProfile\n    not container.securityContext.seLinuxOptions\n    not container.securityContext.capabilities.drop\n}\n\nisUnsafeWorkload(wl) {\n    not wl.spec.template.spec.securityContext.seccompProfile\n    not wl.spec.template.spec.securityContext.seLinuxOptions\n\tannotations := [wl.spec.template.metadata.annotations[i] | annotaion = i; startswith(i, \"container.apparmor.security.beta.kubernetes.io\")]\n\tnot count(annotations) > 0\n}\n\nisUnsafeCronJob(cronjob) {\n    not cronjob.spec.jobTemplate.spec.template.spec.securityContext.seccompProfile\n    not cronjob.spec.jobTemplate.spec.template.spec.securityContext.seLinuxOptions\n\tannotations := [cronjob.spec.jobTemplate.spec.template.metadata.annotations[i] | annotaion = i; startswith(i, \"container.apparmor.security.beta.kubernetes.io\")]\n\tnot count(annotations) > 0\n}\n\n"
    },
    {
        "name": "label-usage-for-resources",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pods",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.recommendedLabels",
                "name": "Recommended Labels",
                "description": "Kubescape checks that workloads have at least one of the following labels."
            }
        ],
        "description": "check if a certain set of labels is defined, this is a configurable control. Initial list: app, tier, phase, version, owner, env.",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n# Deny mutating action unless user is in group owning the resource\n\n\n\ndeny[msga] {\n\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tfixPath := noLabelOrNoLabelUsage(pod, \"\")\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"in the following pods a certain set of labels is not defined: %v\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPath,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n     }\n}\n\n\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tpodSpec := wl.spec.template\n\tbegginingOfPodPath := \"spec.template.\"\n\tfixPath := noLabelUsage(wl, podSpec, begginingOfPodPath)\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v a certain set of labels is not defined:\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPath,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n#handles cronjob\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tpodSpec := wl.spec.jobTemplate.spec.template\n\tbegginingOfPodPath := \"spec.jobTemplate.spec.template.\"\n\tfixPath := noLabelUsage(wl, podSpec, begginingOfPodPath)\n\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjobs a certain set of labels is not defined: %v\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 2,\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": fixPath,\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n     }\n}\n\n# There is no label-usage in WL and also for his Pod\nnoLabelUsage(wl, podSpec, begginingOfPodPath) = path{\n\tpath1 := noLabelOrNoLabelUsage(wl, \"\")\n\tpath2 := noLabelOrNoLabelUsage(podSpec, begginingOfPodPath)\n\tpath = array.concat(path1, path2)\n}\n \n# There is label-usage for WL but not for his Pod\nnoLabelUsage(wl, podSpec, begginingOfPodPath) = path{\n\tnot noLabelOrNoLabelUsage(wl, \"\")\n\tpath := noLabelOrNoLabelUsage(podSpec, begginingOfPodPath)\n}\n\n# There is no label-usage for WL but there is for his Pod\nnoLabelUsage(wl, podSpec, begginingOfPodPath) = path{\n\tnot noLabelOrNoLabelUsage(podSpec, begginingOfPodPath)\n\tpath := noLabelOrNoLabelUsage(wl, \"\")\n}\n\nnoLabelOrNoLabelUsage(wl, begginingOfPath) = path{\n\tnot wl.metadata\n\tpath = [{\"path\": sprintf(\"%vmetadata.labels\", [begginingOfPath]), \"value\": \"YOUR_VALUE\"}]\n}\n\nnoLabelOrNoLabelUsage(wl, begginingOfPath) = path{\n\tmetadata := wl.metadata\n\tnot metadata.labels\n\tpath = [{\"path\": sprintf(\"%vmetadata.labels\", [begginingOfPath]), \"value\": \"YOUR_VALUE\"}]\n}\n\nnoLabelOrNoLabelUsage(wl, begginingOfPath) = path{\n\tlabels := wl.metadata.labels\n\tnot isDesiredLabel(labels)\n\tpath = [{\"path\": sprintf(\"%vmetadata.labels\", [begginingOfPath]), \"value\": \"YOUR_VALUE\"}]\n}\n\nisDesiredLabel(labels) {\n\trecommended_labels := data.postureControlInputs.recommendedLabels\n\trecommended_label := recommended_labels[_]\n\tlabels[recommended_label]\n}\n\n"
    },
    {
        "name": "alert-any-hostpath",
        "attributes": {
            "m$K8sThreatMatrix": "Privilege Escalation::hostPath mount",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob",
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "determines if any workload contains a hostPath volume",
        "remediation": "Try to refrain from using hostPath mounts",
        "ruleQuery": "",
        "rule": "package armo_builtins\n\n\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    volumes := pod.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.\"\n\tresult  := isDangerousHostPath(volume, begginingOfPath, i)\n    podname := pod.metadata.name\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"pod: %v has: %v as hostPath volume\", [podname, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n#handles majority of workload resources\ndeny[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    volumes := wl.spec.template.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    result  := isDangerousHostPath(volume, begginingOfPath, i)\n\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n#handles CronJobs\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n    volumes := wl.spec.jobTemplate.spec.template.spec.volumes\n    volume := volumes[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n    result  := isDangerousHostPath(volume, begginingOfPath, i)\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v has: %v as hostPath volume\", [wl.kind, wl.metadata.name, volume.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [result],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n\n\nisDangerousHostPath(volume, begginingOfPath, i) = path {\n    startswith(volume.hostPath.path, \"/etc\")\n\tpath = sprintf(\"%vvolumes[%v].hostPath.path\", [begginingOfPath, format_int(i, 10)])\n}\n\nisDangerousHostPath(volume, begginingOfPath, i) = path {\n    startswith(volume.hostPath.path, \"/var\")\n\tpath = sprintf(\"%vvolumes[%v].hostPath.path\", [begginingOfPath, format_int(i, 10)])\n}"
    },
    {
        "name": "rule-exposed-dashboard-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Initial Access::Exposed Dashboard",
            "armoBuiltin": true,
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "Service"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if dashboard exists and is exposed",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: deployment, service\n# apiversion: v1\n# fails if dashboard exists and is exposed\n\ndeny[msga] {\n\tdeployment := input[_]\n\tstartswith(deployment.metadata.name, \"kubernetes-dashboard\")\n\tcontainer := deployment.spec.template.spec.containers[j]\n\tversion := trim_prefix(container.image, \"kubernetesui/dashboard:v\")\n\tto_number(replace(version, \".\", \"\")) < 201\n\t\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tisNodePortLbService(service)\n\tcount({x | service.spec.selector[x]; deployment.metadata.labels[x]}) == count(service.spec.selector)\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(j, 10)])\n\n\tdeploymentvector = {\"name\": deployment.metadata.name,\n\t\t\t\t\t\t\"namespace\": deployment.metadata.namespace,\n\t\t\t\t\t\t\"kind\": deployment.kind,\n\t\t\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"dashboard exists and is exposed %s\", [container.image]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": deploymentvector\n\t\t}\n\t}\n}\n\n\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"NodePort\"\n}\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"LoadBalancer\"\n}",
        "resourceEnumerator": "package armo_builtins\n\n# input: deployment, service\n# apiversion: v1\n# fails if dashboard exists and is exposed\n\ndeny[msga] {\n\tdeployment := input[_]\n\tstartswith(deployment.metadata.name, \"kubernetes-dashboard\")\n\tcontainer := deployment.spec.template.spec.containers[j]\n\tversion := trim_prefix(container.image, \"kubernetesui/dashboard:v\")\n\tto_number(replace(version, \".\", \"\")) < 201\n\t\n\tservice := input[_]\n\tservice.kind == \"Service\"\n\tcount({x | service.spec.selector[x]; deployment.metadata.labels[x]}) == count(service.spec.selector)\n\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(j, 10)])\n\n\tdeploymentvector = {\"name\": deployment.metadata.name,\n\t\t\t\t\t\t\"namespace\": deployment.metadata.namespace,\n\t\t\t\t\t\t\"kind\": deployment.kind,\n\t\t\t\t\t\t\"relatedObjects\": [service]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"dashboard exists and is exposed %s\", [container.image]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n\t\t\"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n\t\t\t\"externalObjects\": deploymentvector\n\t\t}\n\t}\n}\n\n\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"NodePort\"\n}\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"LoadBalancer\"\n}"
    },
    {
        "name": "has-critical-vulnerability",
        "attributes": {
            "m$K8sThreatMatrix": "has-critical-vulnerability",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pods",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "image.vulnscan.com"
                ],
                "apiVersions": [
                    "v1"
                ],
                "resources": [
                    "ImageVulnerabilities"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "image has-critical-vulnerability",
        "remediation": "",
        "ruleQuery": "package armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n    \ndeny[msga] {\n \n\t# get pod and imageVulnerabilities\n\tpods := [pod | pod= input[_]; pod.kind == \"Pod\"]\n    vulns := [vuln | vuln = input[_]; vuln.kind == \"ImageVulnerabilities\"]\n    pod := pods[_]\n    vuln := vulns[_]\n    \n\t# get container image name\n\tcontainer := pod.spec.containers[i]\n\n\t# image has vulnerabilities\n\tcontainer.image == vuln.metadata.name\n\n\t# has a \"crirtical\" vulnerability\n\thasCrirticalVulnerability(vuln)\n\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n\n\tmetadata = {\n\t\t\"name\": pod.metadata.name,\n\t\t\"namespace\": pod.metadata.namespace\n\t}\n\tattackvector = {\n\t\t\"apiVersion\": \"result.vulnscan.com/v1\",\n\t\t\"kind\": pod.kind,\n\t\t\"metadata\": metadata,\n\t\t\"relatedObjects\": [pod, vuln]\n\t}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has critical vulnerabilities\", [container.image]),\n        \"alertScore\": 5,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"externalObjects\": attackvector\n\t\t}\n    }\n}\n\n\n#handles majority of workload resources\ndeny[msga] {\n \n    # get pod and imageVulnerabilities\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\n\twls := [wl | wl= input[_]; spec_template_spec_patterns[wl.kind]]\n    vulns := [vuln | vuln = input[_]; vuln.kind == \"ImageVulnerabilities\"]\n    wl := wls[_]\n    vuln := vulns[_]\n    \n\t# get container image name\n\tcontainer := wl.spec.template.spec.containers[i]\n\n\t# image has vulnerabilities\n\tcontainer.image == vuln.metadata.name\n\n\t# has a \"crirtical\" vulnerability\n\thasCrirticalVulnerability(vuln)\n\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\n\tmetadata = {\n\t\t\"name\": wl.metadata.name,\n\t\t\"namespace\": wl.metadata.namespace\n\t}\n\tattackvector = {\n\t\t\"apiVersion\": \"result.vulnscan.com/v1\",\n\t\t\"kind\": wl.kind,\n\t\t\"metadata\": metadata,\n\t\t\"relatedObjects\": [wl, vuln]\n\t}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has critical vulnerabilities\", [container.image]),\n        \"alertScore\": 5,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"externalObjects\": attackvector\n\t\t}\n    }\n}\n\n\n# handles cronjob\ndeny[msga] {\n \n\twls := [wl | wl= input[_]; wl.kind == \"CronJob\"]\n    vulns := [vuln | vuln = input[_]; vuln.kind == \"ImageVulnerabilities\"]\n    wl := wls[_]\n    vuln := vulns[_]\n    \n\t# get container image name\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\n\t# image has vulnerabilities\n\tcontainer.image == vuln.metadata.name\n\n\t# has a \"crirtical\" vulnerability\n\thasCrirticalVulnerability(vuln)\n\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\n\tmetadata = {\n\t\t\"name\": wl.metadata.name,\n\t\t\"namespace\": wl.metadata.namespace\n\t}\n\tattackvector = {\n\t\t\"apiVersion\": \"result.vulnscan.com/v1\",\n\t\t\"kind\": wl.kind,\n\t\t\"metadata\": metadata,\n\t\t\"relatedObjects\": [wl, vuln]\n\t}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has critical vulnerabilities\", [container.image]),\n        \"alertScore\": 5,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"externalObjects\": attackvector\n\t\t}\n    }\n}\n \n\nhasCrirticalVulnerability(vuln){\n\tcount(vuln.data) > 0\n\tdata := vuln.data[_]\n\tdata.severity == \"Critical\"\n}",
        "resourceEnumerator": "package armo_builtins\nimport data.cautils as cautils\n    \ndeny[msga] {\n \n\t# get pod and imageVulnerabilities\n\tpods := [pod | pod= input[_]; pod.kind == \"Pod\"]\n    vulns := [vuln | vuln = input[_]; vuln.kind == \"ImageVulnerabilities\"]\n    pod := pods[_]\n    vuln := vulns[_]\n    \n\t# get container image name\n\tcontainer := pod.spec.containers[i]\n\n\t# image has vulnerabilities\n\tcontainer.image == vuln.metadata.name\n\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n\n\tmetadata = {\n\t\t\"name\": pod.metadata.name,\n\t\t\"namespace\": pod.metadata.namespace\n\t}\n\tattackvector = {\n\t\t\"apiVersion\": \"result.vulnscan.com/v1\",\n\t\t\"kind\": pod.kind,\n\t\t\"metadata\": metadata,\n\t\t\"relatedObjects\": [pod, vuln]\n\t}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has critical vulnerabilities\", [container.image]),\n        \"alertScore\": 5,\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"externalObjects\": attackvector\n\t\t}\n    }\n}\n\n\n#handles majority of workload resources\ndeny[msga] {\n \n    # get pod and imageVulnerabilities\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\n\twls := [wl | wl= input[_]; spec_template_spec_patterns[wl.kind]]\n    vulns := [vuln | vuln = input[_]; vuln.kind == \"ImageVulnerabilities\"]\n    wl := wls[_]\n    vuln := vulns[_]\n    \n\t# get container image name\n\tcontainer := wl.spec.template.spec.containers[i]\n\n\t# image has vulnerabilities\n\tcontainer.image == vuln.metadata.name\n\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\n\tmetadata = {\n\t\t\"name\": wl.metadata.name,\n\t\t\"namespace\": wl.metadata.namespace\n\t}\n\tattackvector = {\n\t\t\"apiVersion\": \"result.vulnscan.com/v1\",\n\t\t\"kind\": wl.kind,\n\t\t\"metadata\": metadata,\n\t\t\"relatedObjects\": [wl, vuln]\n\t}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has critical vulnerabilities\", [container.image]),\n        \"alertScore\": 5,\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"externalObjects\": attackvector\n\t\t}\n    }\n}\n\n# handles cronjob\ndeny[msga] {\n \n\twls := [wl | wl= input[_]; wl.kind == \"CronJob\"]\n    vulns := [vuln | vuln = input[_]; vuln.kind == \"ImageVulnerabilities\"]\n    wl := wls[_]\n    vuln := vulns[_]\n    \n\t# get container image name\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\n\t# image has vulnerabilities\n\tcontainer.image == vuln.metadata.name\n\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\n\tmetadata = {\n\t\t\"name\": wl.metadata.name,\n\t\t\"namespace\": wl.metadata.namespace\n\t}\n\tattackvector = {\n\t\t\"apiVersion\": \"result.vulnscan.com/v1\",\n\t\t\"kind\": wl.kind,\n\t\t\"metadata\": metadata,\n\t\t\"relatedObjects\": [wl, vuln]\n\t}\n\n    msga := {\n        \"alertMessage\": sprintf(\"image %v has critical vulnerabilities\", [container.image]),\n        \"alertScore\": 5,\n\t\t\"failedPaths\": [path],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"externalObjects\": attackvector\n\t\t}\n    }\n}"
    },
    {
        "name": "container-image-repository",
        "attributes": {
            "m$K8sThreatMatrix": "Collection::Images from private registry",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pods",
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "configInputs": [
            "settings.postureControlInputs.imageRepositoryAllowList"
        ],
        "controlConfigInputs": [
            {
                "path": "settings.postureControlInputs.imageRepositoryAllowList",
                "name": "Allowed image repositories",
                "description": "Kubescape checks that all the containers are using images from the allowed repositories provided in the following list."
            }
        ],
        "description": "Fails if image is not from allowed repository",
        "remediation": "",
        "ruleQuery": "",
        "rule": "package armo_builtins\nimport data\n# import data.kubernetes.api.client as client\n\nuntrustedImageRepo[msga] {\n\tpod := input[_]\n\tpod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\timage := container.image\n\tnot imageInAllowedList(image)\n\tpath := sprintf(\"spec.containers[%v].image\", [format_int(i, 10)])\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"image '%v' in container '%s' comes from untrusted registry\", [image, container.name]),\n\t\t\"alertScore\": 2,\n        \"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\nuntrustedImageRepo[msga] {\n\twl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n\tcontainer := wl.spec.template.spec.containers[i]\n\timage := container.image\n    not imageInAllowedList(image)\n\n\tpath := sprintf(\"spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"image '%v' in container '%s' comes from untrusted registry\", [image, container.name]),\n\t\t\"alertScore\": 2,\n        \"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nuntrustedImageRepo[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer := wl.spec.jobTemplate.spec.template.spec.containers[i]\n\timage := container.image\n    not imageInAllowedList(image)\n\n\tpath := sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].image\", [format_int(i, 10)])\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"image '%v' in container '%s' comes from untrusted registry\", [image, container.name]),\n\t\t\"alertScore\": 2,\n        \"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nimageInAllowedList(image){\n\t# see default-config-inputs.json for list values\n\tallowedlist := data.postureControlInputs.imageRepositoryAllowList\n\tregistry := allowedlist[_]\n\tregex.match(registry, image)\n}"
    },
    {
        "name": "rule-can-create-pod-kube-system-v1",
        "attributes": {
            "microsoftK8sThreatMatrix": "Discovery::Access the K8s API server",
            "armoBuiltin": true,
            "resourcesAggregator": "subject-role-rolebinding",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [
            {
                "packageName": "cautils"
            }
        ],
        "description": "determines which users can create pods in kube-system namespace",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# fails if user has create access to pods within kube-system namespace\ndeny[msga] {\n    subjectVector := input[_]\n    role := subjectVector.relatedObjects[i]\n    rolebinding := subjectVector.relatedObjects[j]\n    endswith(subjectVector.relatedObjects[i].kind, \"Role\")\n    endswith(subjectVector.relatedObjects[j].kind, \"Binding\")\n\n\n    canCreateToPodNamespace(role)\n    rule:= role.rules[p]\n\n\tsubject := rolebinding.subjects[k]\n\n\tverbs := [\"create\", \"*\"]\n    verbsPath := [sprintf(\"relatedObjects[%v].rules[%v].verbs[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | verb =  rule.verbs[l];cautils.list_contains(verbs, verb)]\n\tcount(verbsPath) > 0\n\n\tapiGroups := [\"\", \"*\"]\n\tapiGroupsPath := [sprintf(\"relatedObjects[%v].rules[%v].apiGroups[%v]\", [format_int(i, 10),format_int(p, 10), format_int(a, 10)])  | apiGroup =  rule.apiGroups[a];cautils.list_contains(apiGroups, apiGroup)]\n\tcount(apiGroupsPath) > 0\n\n\tresources := [\"pods\", \"*\"]\n\tresourcesPath := [sprintf(\"relatedObjects[%v].rules[%v].resources[%v]\", [format_int(i, 10),format_int(p, 10), format_int(l, 10)])  | resource =  rule.resources[l]; cautils.list_contains(resources, resource)]\n\tcount(resourcesPath) > 0\n\n\n\tpath := array.concat(resourcesPath, verbsPath)\n\tpath2 := array.concat(path, apiGroupsPath)\n\tpath3 := array.concat(path2, [sprintf(\"relatedObjects[%v].roleRef.subjects[%v]\", [format_int(j, 10), format_int(k, 10)])])\n\tfinalpath := array.concat(path3, [sprintf(\"relatedObjects[%v].roleRef.name\", [format_int(j, 10)])])\n\n\t\n\n    msga := {\n        \"alertMessage\": sprintf(\"Subject: %v-%v can create pods in kube-system\", [subjectVector.kind, subjectVector.name]),\n        \"alertScore\": 3,\n         \"failedPaths\": finalpath,\n         \"fixPaths\": [],\n        \"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n            \"k8sApiObjects\": [],\n            \"externalObjects\": subjectVector\n        }\n    }\n}\n\ncanCreateToPodNamespace(role) {\n    role.metadata.namespace == \"kube-system\"\n}\n"
    },
    {
        "name": "Symlink-Exchange-Can-Allow-Host-Filesystem-Access",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob",
                    "Node"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "A user may be able to create a container with subPath volume mounts to access files & directories outside of the volume, including on the host filesystem. This was affected at the following versions: v1.22.0 - v1.22.1, v1.21.0 - v1.21.4, v1.20.0 - v1.20.10, version v1.19.14 and lower. ",
        "remediation": "To mitigate this vulnerability without upgrading kubelet, you can disable the VolumeSubpath feature gate on kubelet and kube-apiserver, and remove any existing Pods making use of the feature.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\tbegginingOfPath := \"spec.\"\n    finalpath := isSubPathContainer(container, i, begginingOfPath)\n\n\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25741. You have a Node with a vulnerable version and the following container : %v in pod : %v with subPath/subPathExpr\", [container.name, pod.metadata.name]),\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [pod]},\n\t\t\t\"failedPaths\": finalpath,\n\t\t\t\"fixPaths\": [],\n\t\t}\n}\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.template.spec.\"\n    finalpath := isSubPathContainer(container, i, begginingOfPath)\n       \n\tmsga := {\n\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25741. You have a Node with a vulnerable version and the following container : %v in %v : %v with subPath/subPathExpr\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": finalpath,\n\t\t\t\"fixPaths\": [],\n\t\t}\n}\n\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n    wl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\tbegginingOfPath := \"spec.jobTemplate.spec.template.spec.\"\n    finalpath := isSubPathContainer(container, i, begginingOfPath)\n    \n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"You may be vulnerable to CVE-2021-25741. You have a Node with a vulnerable version and the following container : %v in %v : %v with subPath/subPathExpr\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": finalpath,\n\t\t\t\"fixPaths\": [],\n\t\t}\n}\n\n\n\nisSubPathContainer(container, i, begginingOfPath) = path {\n\tpath = [sprintf(\"%vcontainers[%v].volumeMounts[%v].subPath\" ,[begginingOfPath, format_int(i, 10), format_int(j, 10)]) | volumeMount = container.volumeMounts[j];  volumeMount.subPath]\n\tcount(path) > 0\n}\n\nisVulnerableVersion(version)  {\n    version <=  \"v1.19.14\"\n}\n\nisVulnerableVersion(version){\n    version >= \"v1.22.0\"\n    version <= \"v1.22.1\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.21.0\"\n    version <= \"v1.21.4\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.20.0\"\n    version <= \"v1.20.9\"\n}\n\nisVulnerableVersion(version){\n\tversion == \"v1.20.10\"\n}\n\n\n",
        "resourceEnumerator": "package armo_builtins\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n\tversionPath = \"status.nodeInfo.kubeletVersion\"\n    pod := input[_]\n    pod.kind == \"Pod\"\n\n\tmsga := {\n\t\t\t\"alertMessage\": \"\",\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [pod]},\n\t\t\t\"failedPaths\": [\"\"],\n\t}\n}\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n\tversionPath = \"status.nodeInfo.kubeletVersion\"\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n       \n\tmsga := {\n\t\"alertMessage\": \"\",\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": [\"\"],\n\t}\n}\n\n\n\ndeny[msga] {\n\tnodes := input[_]\n\tcurrent_version := nodes.status.nodeInfo.kubeletVersion\n    isVulnerableVersion(current_version)\n\tversionPath = \"status.nodeInfo.kubeletVersion\"\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    \n\tmsga := {\n\t\t\"alertMessage\": \"\",\n\t\t\t\"alertObject\": {\"k8SApiObjects\": [wl]},\n\t\t\t\"failedPaths\": [\"\"],\n\t}\n}\n\n\nisVulnerableVersion(version)  {\n    version <=  \"v1.19.14\"\n}\n\nisVulnerableVersion(version){\n    version >= \"v1.22.0\"\n    version <= \"v1.22.1\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.21.0\"\n    version <= \"v1.21.4\"\n}\n\n\nisVulnerableVersion(version){\n    version >= \"v1.20.0\"\n    version <= \"v1.20.9\"\n}\n\nisVulnerableVersion(version){\n\tversion == \"v1.20.10\"\n}"
    },
    {
        "name": "rule-exposed-dashboard",
        "attributes": {
            "m$K8sThreatMatrix": "Initial Access::Exposed Dashboard",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "Service"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if dashboard exists and is exposed",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "\tpackage armo_builtins\n\n\t# input: pods\n\t# apiversion: v1\n\t# fails if dashboard exists and is exposed\n\n\tdeny[msga] {\n\t\tdeployment := input[_]\n\t\tstartswith(deployment.metadata.name, \"kubernetes-dashboard\")\n\t\tcontainer := deployment.spec.template.spec.containers[j]\n\t\tversion := trim_prefix(container.image, \"kubernetesui/dashboard:v\")\n\t\tto_number(replace(version, \".\", \"\")) < 201\n\t\t\n\t\tservice := input[_]\n\t\tservice.kind == \"Service\"\n\t\tisNodePortLbService(service)\n\t\tcount({x | service.spec.selector[x]; deployment.metadata.labels[x]}) == count(service.spec.selector)\n\t\tpath := sprintf(\"spec.template.spec.containers[%v]\", [format_int(j, 10)])\n\n\t\tmsga := {\n\t\t\t\"alertMessage\": sprintf(\"dashboard exists and is exposed %s\", [container.image]),\n\t\t\t\"alertScore\": 9,\n\t\t\t\"fixPaths\": [],\n\t\t\t\"failedPaths\": [path],\n\t\t\t\"packagename\": \"armo_builtins\",\n\t\t\t\"alertObject\": {\n\t\t\t\t\"k8sApiObjects\": [deployment]\n\t\t\t}\n\t\t}\n\t}\n\n\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"NodePort\"\n}\n\nisNodePortLbService(service) {\n\tservice.spec.type == \"LoadBalancer\"\n}"
    },
    {
        "name": "resources-memory-limit-and-request",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "memory limits and requests are not set.",
        "remediation": "Ensure memory limits and requests are set.",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if pod doas not have container with memory-limit or request\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    container := pod.spec.containers[i]\n\tnot request_or_limit_memory(container)\n\tfixPaths := [{\"path\": sprintf(\"spec.containers[%v].resources.limits.memory\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}, \n\t\t\t\t{\"path\": sprintf(\"spec.containers[%v].resources.requests.memory\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v does not have memory-limit or request\", [ container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixPaths,\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if workload doas not have container with memory-limit or request\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n    not request_or_limit_memory(container)\n\tfixPaths := [{\"path\": sprintf(\"spec.containers[%v].resources.limits.memory\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}, \n\t\t\t\t{\"path\": sprintf(\"spec.containers[%v].resources.requests.memory\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have memory-limit or request\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixPaths,\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if cronjob doas not have container with memory-limit or request\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n    not request_or_limit_memory(container)\n\tfixPaths := [{\"path\": sprintf(\"spec.containers[%v].resources.limits.memory\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}, \n\t\t\t\t{\"path\": sprintf(\"spec.containers[%v].resources.requests.memory\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}]\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have memory-limit or request\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"fixPaths\": fixPaths,\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\nrequest_or_limit_memory(container) {\n\tcontainer.resources.limits.memory\n\tcontainer.resources.requests.memory\n}\n"
    },
    {
        "name": "internal-networking",
        "attributes": {
            "m$K8sThreatMatrix": "Lateral Movement::Container internal networking, Discovery::Network mapping",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "networkpolicies",
                    "namespaces"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "lists namespaces in which no network policies are defined",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: network policies\n# apiversion: networking.k8s.io/v1\n# fails if no network policies are defined in a certain namespace\n\ndeny[msga] {\n\tnamespaces := [namespace | namespace = input[_]; namespace.kind == \"Namespace\"]\n\tnamespace := namespaces[_]\n\tpolicy_names := [policy.metadata.namespace | policy = input[_]; policy.kind == \"NetworkPolicy\"]\n\tnot list_contains(policy_names, namespace.metadata.name)\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"no policy is defined for namespace %v\", [namespace.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [namespace]\n\t\t}\n\t}\n}\n\nlist_contains(list, element) {\n  some i\n  list[i] == element\n}",
        "resourceEnumerator": "package armo_builtins\n\n# input: network policies + namespaces\n# apiversion: networking.k8s.io/v1\n# returns all namespaces\n\ndeny[msga] {\n\tnamespaces := [namespace | namespace = input[_]; namespace.kind == \"Namespace\"]\n\tnamespace := namespaces[_]\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"no policy is defined for namespace %v\", [namespace.metadata.name]),\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [namespace]\n\t\t}\n\t}\n}"
    },
    {
        "name": "rule-excessive-delete-rights",
        "attributes": {
            "m$K8sThreatMatrix": "Impact::Data Destruction",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Role",
                    "ClusterRole",
                    "ClusterRoleBinding",
                    "RoleBinding"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if user can delete important resources",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n\n# fails if user can can delete important resources\n#RoleBinding to Role\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"Role\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteResource(rule)\n    canDeleteVerb(rule)\n\n    rolebinding.roleRef.kind == \"Role\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete important resources\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\n# fails if user can can delete important resources\n#RoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n    role:= roles[_]\n    rolebinding := rolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteResource(rule)\n    canDeleteVerb(rule)\n\n    rolebinding.roleRef.kind == \"ClusterRole\"\n    rolebinding.roleRef.name == role.metadata.name\n\n    subject := rolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete important resources\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,rolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n# fails if user can can delete important resources\n# ClusterRoleBinding to ClusterRole\ndeny[msga] {\n    roles := [role |  role= input[_]; role.kind == \"ClusterRole\"]\n    clusterrolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n    role:= roles[_]\n    clusterrolebinding := clusterrolebindings[_]\n\n    rule:= role.rules[_]\n    canDeleteResource(rule)\n    canDeleteVerb(rule)\n\n    clusterrolebinding.roleRef.kind == \"ClusterRole\"\n    clusterrolebinding.roleRef.name == role.metadata.name\n\n\n    subject := clusterrolebinding.subjects[i]\n    path := sprintf(\"subjects[%v]\", [format_int(i, 10)])\n\n    msga := {\n\t    \"alertMessage\": sprintf(\"The following %v: %v can delete important resources\", [subject.kind, subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"fixPaths\": [],\n        \"failedPaths\": [path],\n\t\t\"packagename\": \"armo_builtins\",\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [role,clusterrolebinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n    }\n}\n\n\ncanDeleteVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"delete\")\n}\n\ncanDeleteVerb(rule) {\n\tcautils.list_contains(rule.verbs, \"deletecollection\")\n}\n\ncanDeleteVerb(rule)  {\n\tcautils.list_contains(rule.verbs, \"*\")\n}\n\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"secrets\")\n}\ncanDeleteResource(rule)  {\n\tcautils.list_contains(rule.resources, \"pods\")\n}\ncanDeleteResource(rule)  {\n\tcautils.list_contains(rule.resources, \"services\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"deployments\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"replicasets\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"daemonsets\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"statefulsets\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"jobs\")\n}\ncanDeleteResource(rule) {\n\tcautils.list_contains(rule.resources, \"cronjobs\")\n}\ncanDeleteResource(rule)  {\n    isApiGroup(rule)\n\tcautils.list_contains(rule.resources, \"*\")\n}\n\n\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"*\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"apps\"\n}\nisApiGroup(rule) {\n\tapiGroup := rule.apiGroups[_]\n\tapiGroup == \"batch\"\n}\n\n"
    },
    {
        "name": "psp-enabled-cloud",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [],
                "apiVersions": [],
                "resources": []
            }
        ],
        "dynamicMatch": [
            {
                "apiGroups": [
                    "container.googleapis.com",
                    "eks.amazonaws.com"
                ],
                "apiVersions": [
                    "v1"
                ],
                "resources": [
                    "ClusterDescribe"
                ]
            }
        ],
        "relevantCloudProviders": [
            "EKS",
            "GKE"
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Check if PSP is enabled for GKE\ndeny[msga] {\n\tclusterConfig := input[_]\n\tclusterConfig.apiVersion == \"container.googleapis.com/v1\"\n\tclusterConfig.kind == \"ClusterDescribe\"\n    clusterConfig.metadata.provider == \"gke\"\t\n\tconfig := clusterConfig.data\n    not config.pod_security_policy_config.enabled == true\n\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"pod security policy configuration is not enabled\",\n\t\t\"alertScore\": 3,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [],\n\t\t\"fixPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": clusterConfig\n\t\t}\n\t}\n}\n\n# TODO - EKS. By default has a policy which allows everything"
    },
    {
        "name": "access-container-service-account-v1",
        "attributes": {
            "m$K8sThreatMatrix": "Credential Access::Access container service account, Lateral Movement::Container service account",
            "armoBuiltin": true,
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob",
                    "ServiceAccounts",
                    "RoleBinding",
                    "ClusterRoleBinding",
                    "Role",
                    "ClusterRole"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "determines which service accounts can be used to access other resources in the cluster",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\n\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    not saTokenNotAutoMount(serviceaccount)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [],\n        \"fixPaths\":[],\n\t\t\"alertScore\": 7,\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    not saTokenNotAutoMount(serviceaccount)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [],\n        \"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    not saTokenNotAutoMount(serviceaccount)\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [],\n        \"fixPaths\":[],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# ===============================================================\n\nsaTokenNotAutoMount(serviceaccount) {\n    serviceaccount.automountServiceAccountToken == false\n}\n\n",
        "resourceEnumerator": "package armo_builtins\n\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"Role\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n        \"failedPaths\": [\"\"],\n\t\t\"alertScore\": 7,\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"RoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}\n\n# Returns the rbac permission of each service account\ndeny[msga] {\n    serviceAccounts := [serviceaccount |  serviceaccount= input[_]; serviceaccount.kind == \"ServiceAccount\"]\n    serviceaccount := serviceAccounts[_]\n    serviceAccountName := serviceaccount.metadata.name\n\n    rolebindings := [rolebinding | rolebinding = input[_]; rolebinding.kind == \"ClusterRoleBinding\"]\n\trolebinding := rolebindings[_]\n    rolesubject := rolebinding.subjects[_]\n    rolesubject.name == serviceAccountName\n    rolesubject.namespace == serviceaccount.metadata.namespace\n\n    roles := [role |  role = input[_]; role.kind == \"ClusterRole\"]\n    role := roles[_]\n    role.metadata.name == rolebinding.roleRef.name\n\n    savector = {\"name\": serviceaccount.metadata.name,\n\t\t\t\t\"namespace\": serviceaccount.metadata.namespace,\n\t\t\t\t\"kind\": serviceaccount.kind,\n\t\t\t\t\"relatedObjects\": [role, rolebinding]}\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"service account: %v has the following permissions in the cluster: %v\", [serviceAccountName, rolebinding.roleRef.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n        \"failedPaths\": [\"\"],\n        \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [],\n            \"externalObjects\": savector\n\t\t}\n\t}\n}"
    },
    {
        "name": "etcd-encryption-native",
        "attributes": {
            "armoBuiltin": true,
            "resourcesAggregator": "apiserver-pod",
            "useFromKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\nimport data.cautils as cautils\n\n# Check if encryption in etcd is enabled for native k8s\ndeny[msga] {\n\tapiserverpod := input[_]\n    cmd := apiserverpod.spec.containers[0].command\n    encCommand :=  [ command |command := cmd[_] ; contains(command, \"--encryption-provider-config=\")]\n    count(encCommand) < 1\n\tpath := \"spec.containers[0].command\"\t\n\t\n\tmsga := {\n\t\t\"alertMessage\": \"etcd encryption is not enabled\",\n\t\t\"alertScore\": 9,\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [apiserverpod],\n\t\t\n\t\t}\n\t}\n}"
    },
    {
        "name": "image-pull-secrets",
        "attributes": {
            "m$K8sThreatMatrix": "Collection::Images from private registry",
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "ServiceAccounts"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Checks if more than on service account have access to an ImagePullSecrets",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n# input: service accounts\n# apiversion: v1 \n# returns ImagePullSecrets that more than one service account have access to\n\ndeny[msga] {\n\n    image = input[i].imagePullSecrets[k] == input[j].imagePullSecrets[_]\n\tpath := sprintf(\"imagePullSecrets[%v]\", [format_int(k, 10)])\n\ti > j\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following ImagePullSecret: %v, is exposed to more than one serviceaccount\", [image]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [path],\n\t\t\"fixPaths\":[],\n\t\t\"packagename\": \"armo_builtins\",\n\t   \"alertObject\": {\n\t\t}\n\t}\n}"
    },
    {
        "name": "configured-liveness-probe",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Pod"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "Liveness probe is not configured",
        "remediation": "Ensure Liveness probe is configured",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n# Fails if  container does not have livenessProbe - for pod\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n    container := pod.spec.containers[i]\n\tnot container.livenessProbe\n\tfixPath := {\"path\": sprintf(\"spec.containers[%v].livenessProbe\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v does not have livenessProbe\", [ container.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 4,\n\t\t\"fixPaths\": [fixPath],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# Fails if  container does not have livenessProbe - for wl\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n    not container.livenessProbe\n\tfixPath := {\"path\": sprintf(\"spec.template.spec.containers[%v].livenessProbe\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have livenessProbe\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 4,\n\t\t\"fixPaths\": [fixPath],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if  container does not have livenessProbe - for cronjob\ndeny[msga] {\n  \twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n    not container.livenessProbe\n\tfixPath := {\"path\": sprintf(\"spec.jobTemplate.spec.template.spec.containers[%v].livenessProbe\", [format_int(i, 10)]), \"value\": \"YOUR_VALUE\"}\n    msga := {\n\t\t\"alertMessage\": sprintf(\"Container: %v in %v: %v   does not have livenessProbe\", [ container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 4,\n\t\t\"fixPaths\": [fixPath],\n\t\t\"failedPaths\": [],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n"
    },
    {
        "name": "non-root-containers",
        "attributes": {
            "armoBuiltin": true
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "Deployment",
                    "ReplicaSet",
                    "DaemonSet",
                    "StatefulSet",
                    "Job",
                    "Pod",
                    "CronJob"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if container can run as root",
        "remediation": "Make sure that the user/group in the securityContext of pod/container is set to an id less than 1000, or the runAsNonRoot flag is set to true. Also make sure that the allowPrivilegeEscalation field is set to false",
        "ruleQuery": "armo_builtins",
        "rule": "package armo_builtins\n\n\n################################################################################\n# Rules\ndeny[msga] {\n    pod := input[_]\n    pod.kind == \"Pod\"\n\tcontainer := pod.spec.containers[i]\n\n\tbegginingOfPath := \"spec\"\n\talertInfo := evaluateWorkloadNonRootContainer(container, pod, begginingOfPath)\n\tfixPath := getFixedPath(alertInfo, i)\n    failedPath := getFailedPath(alertInfo, i) \n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container: %v in pod: %v  may run as root\", [container.name, pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n        \"fixPaths\": fixPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    container := wl.spec.template.spec.containers[i]\n\n\tbegginingOfPath := \"spec.template.spec\"\n\talertInfo := evaluateWorkloadNonRootContainer(container, wl.spec.template, begginingOfPath)\n\tfixPath := getFixedPath(alertInfo, i)\n    failedPath := getFailedPath(alertInfo, i) \n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v may run as root\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n        \"fixPaths\": fixPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# Fails if cronjob has a container configured to run as root\ndeny[msga] {\n\twl := input[_]\n\twl.kind == \"CronJob\"\n\tcontainer = wl.spec.jobTemplate.spec.template.spec.containers[i]\n\n\tbegginingOfPath := \"spec.jobTemplate.spec.template\"\n\talertInfo := evaluateWorkloadNonRootContainer(container, wl.spec.jobTemplate.spec.template, begginingOfPath)\n\tfixPath := getFixedPath(alertInfo, i)\n    failedPath := getFailedPath(alertInfo, i) \n\t\n\n    msga := {\n\t\t\"alertMessage\": sprintf(\"container :%v in %v: %v  may run as root\", [container.name, wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": failedPath,\n        \"fixPaths\": fixPath,\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\ngetFailedPath(alertInfo, i) = [replace(alertInfo.failedPath,\"container_ndx\",format_int(i,10))] {\n\talertInfo.failedPath != \"\"\n} else = []\n\n\ngetFixedPath(alertInfo, i) = [{\"path\":replace(alertInfo.fixPath[0].path,\"container_ndx\",format_int(i,10)), \"value\":alertInfo.fixPath[0].value}, {\"path\":replace(alertInfo.fixPath[1].path,\"container_ndx\",format_int(i,10)), \"value\":alertInfo.fixPath[1].value}]{\n\tcount(alertInfo.fixPath) == 2\n} else = [{\"path\":replace(alertInfo.fixPath[0].path,\"container_ndx\",format_int(i,10)), \"value\":alertInfo.fixPath[0].value}] {\n\tcount(alertInfo.fixPath) == 1\n}  else = []\n\n#################################################################################\n# Workload evaluation \n\nevaluateWorkloadNonRootContainer(container, pod, begginingOfPath) = alertInfo {\n\trunAsNonRootValue := getRunAsNonRootValue(container, pod, begginingOfPath)\n\trunAsNonRootValue.value == false\n\t\n\trunAsUserValue := getRunAsUserValue(container, pod, begginingOfPath)\n\trunAsUserValue.value == 0\n\n\talertInfo := chooseFirstIfDefined(runAsUserValue, runAsNonRootValue)\n} else = alertInfo {\n    allowPrivilegeEscalationValue := getAllowPrivilegeEscalation(container, pod, begginingOfPath)\n    allowPrivilegeEscalationValue.value == true\n\n    alertInfo := allowPrivilegeEscalationValue\n}\n\n\n#################################################################################\n# Value resolution functions\n\n\ngetRunAsNonRootValue(container, pod, begginingOfPath) = runAsNonRoot {\n    failedPath := sprintf(\"%v.container[container_ndx].securityContext.runAsNonRoot\", [begginingOfPath]) \n    runAsNonRoot := {\"value\" : container.securityContext.runAsNonRoot, \"failedPath\" : failedPath, \"fixPath\": [] ,\"defined\" : true}\n} else = runAsNonRoot {\n\tfailedPath := sprintf(\"%v.securityContext.runAsNonRoot\", [begginingOfPath]) \n    runAsNonRoot := {\"value\" : pod.spec.securityContext.runAsNonRoot,  \"failedPath\" : failedPath, \"fixPath\": [], \"defined\" : true}\n} else = {\"value\" : false,  \"failedPath\" : \"\", \"fixPath\": [{\"path\": \"spec.securityContext.runAsNonRoot\", \"value\":\"true\"}], \"defined\" : false} {\n\tisAllowPrivilegeEscalationField(container, pod)\n} else = {\"value\" : false,  \"failedPath\" : \"\", \"fixPath\": [{\"path\":  sprintf(\"%v.securityContext.runAsNonRoot\", [begginingOfPath]) , \"value\":\"true\"}, {\"path\":sprintf(\"%v.securityContext.allowPrivilegeEscalation\", [begginingOfPath]), \"value\":\"false\"}], \"defined\" : false}\n\ngetRunAsUserValue(container, pod, begginingOfPath) = runAsUser {\n\tfailedPath := sprintf(\"%v.container[container_ndx].securityContext.runAsUser\", [begginingOfPath]) \n    runAsUser := {\"value\" : container.securityContext.runAsUser,  \"failedPath\" : failedPath,  \"fixPath\": [], \"defined\" : true}\n} else = runAsUser {\n\tfailedPath := sprintf(\"%v.securityContext.runAsUser\", [begginingOfPath]) \n    runAsUser := {\"value\" : pod.spec.securityContext.runAsUser,  \"failedPath\" : failedPath, \"fixPath\": [],\"defined\" : true}\n} else = {\"value\" : 0, \"failedPath\": \"\", \"fixPath\": [{\"path\":  sprintf(\"%v.securityContext.runAsNonRoot\", [begginingOfPath]), \"value\":\"true\"}],\"defined\" : false}{\n\tisAllowPrivilegeEscalationField(container, pod)\n} else = {\"value\" : 0, \"failedPath\": \"\", \n\t\"fixPath\": [{\"path\":  sprintf(\"%v.securityContext.runAsNonRoot\", [begginingOfPath]), \"value\":\"true\"},{\"path\":  sprintf(\"%v.securityContext.allowPrivilegeEscalation\", [begginingOfPath]), \"value\":\"false\"}],\n\t\"defined\" : false}\n\ngetRunAsGroupValue(container, pod, begginingOfPath) = runAsGroup {\n\tfailedPath := sprintf(\"%v.container[container_ndx].securityContext.runAsGroup\", [begginingOfPath])\n    runAsGroup := {\"value\" : container.securityContext.runAsGroup,  \"failedPath\" : failedPath, \"fixPath\": [],\"defined\" : true}\n} else = runAsGroup {\n\tfailedPath := sprintf(\"%v.securityContext.runAsGroup\", [begginingOfPath])\n    runAsGroup := {\"value\" : pod.spec.securityContext.runAsGroup,  \"failedPath\" : failedPath, \"fixPath\":[], \"defined\" : true}\n} else = {\"value\" : 0, \"failedPath\": \"\", \"fixPath\": [{\"path\": \"spec.securityContext.runAsNonRoot\", \"value\":\"true\"}], \"defined\" : false}{\n\tisAllowPrivilegeEscalationField(container, pod)\n} else = {\"value\" : 0, \"failedPath\": \"\", \n\t\"fixPath\": [{\"path\": sprintf(\"%v.securityContext.runAsNonRoot\", [begginingOfPath]), \"value\":\"true\"},{\"path\": sprintf(\"%v.securityContext.allowPrivilegeEscalation\", [begginingOfPath]), \"value\":\"false\"}],\n \t\"defined\" : false\n}\n\ngetAllowPrivilegeEscalation(container, pod, begginingOfPath) = allowPrivilegeEscalation {\n\tfailedPath := sprintf(\"%v.container[container_ndx].securityContext.allowPrivilegeEscalation\", [begginingOfPath])\n    allowPrivilegeEscalation := {\"value\" : container.securityContext.allowPrivilegeEscalation,  \"failedPath\" : failedPath, \"fixPath\": [],\"defined\" : true}\n} else = allowPrivilegeEscalation {\n\tfailedPath := sprintf(\"%v.securityContext.allowPrivilegeEscalation\", [begginingOfPath])\n    allowPrivilegeEscalation := {\"value\" : pod.spec.securityContext.allowPrivilegeEscalation,  \"failedPath\" : failedPath, \"fixPath\": [],\"defined\" : true}\n} else = {\"value\" : true, \"failedPath\": \"\", \"fixPath\": [{\"path\": sprintf(\"%v.securityContext.allowPrivilegeEscalation\", [begginingOfPath]), \"value\":\"false\"}], \"defined\" : false}\n\nchooseFirstIfDefined(l1, l2) = c {\n    l1.defined\n    c := l1\n} else = l2\n\n\nisAllowPrivilegeEscalationField(container, pod) {\n\tcontainer.securityContext.allowPrivilegeEscalation == false\n}\n\nisAllowPrivilegeEscalationField(container, pod) {\n\tpod.spec.securityContext.allowPrivilegeEscalation == false\n}\n\n\n"
    },
    {
        "name": "rule-access-dashboard",
        "attributes": {
            "m$K8sThreatMatrix": "Lateral Movement::Access Kubernetes dashboard, Discovery::Access Kubernetes dashboard",
            "armoBuiltin": true,
            "useUntilKubescapeVersion": "v1.0.133"
        },
        "ruleLanguage": "Rego",
        "match": [
            {
                "apiGroups": [
                    "*"
                ],
                "apiVersions": [
                    "*"
                ],
                "resources": [
                    "RoleBinding",
                    "ClusterRoleBinding"
                ]
            }
        ],
        "ruleDependencies": [],
        "description": "fails if subject that is not dashboard service account is bound to dashboard role/clusterrole, or- if anyone that is not dashboard pod is associated with its service account.",
        "remediation": "",
        "ruleQuery": "armo_builtins",
        "resourceCount": "subjects",
        "rule": "package armo_builtins\n\n# input: roleBinding\n# apiversion: v1\n# fails if a subject that is not dashboard service account is bound to dashboard role\n\ndeny[msga] {\n\troleBinding := input[_]\n    roleBinding.kind == \"RoleBinding\"\n    roleBinding.roleRef.name == \"kubernetes-dashboard\"\n    subject := roleBinding.subjects[_]\n    subject.name != \"kubernetes-dashboard\"\n    subject.kind != \"ServiceAccount\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following subjects: %s are bound to dashboard role/clusterrole\", [subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"packagename\": \"armo_builtins\",\n         \"alertObject\": {\n\t\t\t\"k8sApiObjects\": [roleBinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n     }\n}\n\n# input: clusterRoleBinding\n# apiversion: v1\n# fails if a subject that is not dashboard service account is bound to dashboard role\n\ndeny[msga] {\n\troleBinding := input[_]\n    roleBinding.kind == \"ClusterRoleBinding\"\n    roleBinding.roleRef.name == \"kubernetes-dashboard\"\n    subject := roleBinding.subjects[_]\n    subject.name != \"kubernetes-dashboard\"\n    subject.kind != \"ServiceAccount\"\n\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following subjects: %s are bound to dashboard role/clusterrole\", [subject.name]),\n\t\t\"alertScore\": 9,\n\t\t\"failedPaths\": [\"\"],\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [roleBinding],\n\t\t\t\"externalObjects\": {\n\t\t\t\t\"subject\" : [subject]\n\t\t\t}\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if pod that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    pod := input[_]\n    pod.spec.serviceaccountname == \"kubernetes-dashboard\"\n    not startswith(pod.metadata.name, \"kubernetes-dashboard\")\n\tpath := \"spec.serviceaccountname\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following pods: %s are associated with dashboard service account\", [pod.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [pod]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if workload that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\tspec_template_spec_patterns := {\"Deployment\",\"ReplicaSet\",\"DaemonSet\",\"StatefulSet\",\"Job\"}\n\tspec_template_spec_patterns[wl.kind]\n    wl.spec.template.spec.serviceaccountname == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\tpath := \"spec.template.spec.serviceaccountname\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"%v: %v is associated with dashboard service account\", [wl.kind, wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}\n\n# input: \n# apiversion: \n# fails if CronJob that is not dashboard is associated to dashboard service account\n\ndeny[msga] {\n    wl := input[_]\n\twl.kind == \"CronJob\"\n    wl.spec.jobTemplate.spec.template.spec.serviceaccountname == \"kubernetes-dashboard\"\n    not startswith(wl.metadata.name, \"kubernetes-dashboard\")\n\tpath := \"spec.jobTemplate.spec.template.spec.serviceaccountname\"\n\tmsga := {\n\t\t\"alertMessage\": sprintf(\"the following cronjob: %s is associated with dashboard service account\", [wl.metadata.name]),\n\t\t\"packagename\": \"armo_builtins\",\n\t\t\"alertScore\": 7,\n\t\t\"failedPaths\": [path],\n\t\t\"alertObject\": {\n\t\t\t\"k8sApiObjects\": [wl]\n\t\t}\n\t}\n}"
    }
]